====== Macro AND ======

====Syntax====

\DefmacWithValues and {\starparam{form}} {\starparam{result}}

====Arguments and Values====

//form// - a //[[CL:Glossary:form]]//.

//results// - the //[[CL:Glossary:values]]// resulting from the evaluation of the last //form//, or the symbols **[[CL:Constant Variables:nil]]** or \t.

====Description====

The macro **[[CL:Macros:and]]** evaluates each //form// one at a time from left to right. As soon as any //form// evaluates to **[[CL:Constant Variables:nil]]**, **[[CL:Macros:and]]** returns **[[CL:Constant Variables:nil]]** without evaluating the remaining //forms//. If all //forms// but the last evaluate to //[[CL:Glossary:true]]// values, **[[CL:Macros:and]]** returns the results produced by evaluating the last //form//.

If no //forms// are supplied, ''(and)'' returns \t.

**[[CL:Macros:and]]** passes back multiple values from the last //[[CL:Glossary:subform]]// but not from subforms other than the last.

====Examples====

<blockquote> (if (and (>= n 0) (< n (length a-simple-vector)) (eq (elt a-simple-vector n) 'foo)) (princ "Foo!")) </blockquote> The above expression prints ''Foo!'' if element ''n'' of ''a-simple-vector'' is the symbol ''foo'', provided also that ''n'' is indeed a valid index for ''a-simple-vector''. Because **[[CL:Macros:and]]** guarantees left-to-right testing of its parts, **[[CL:Functions:elt]]** is not called if ''n'' is out of range.

<blockquote> ([[CL:Macros:defparameter]] temp1 1 temp2 1 temp3 1) → 1 (and (incf temp1) (incf temp2) (incf temp3)) → 2 (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) → //[[CL:Glossary:true]]// (decf temp3) → 1 (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) → NIL (and (eql temp1 temp2) (eql temp2 temp3)) → //[[CL:Glossary:true]]// (and) → T </blockquote>

====Affected By====

None.

====Exceptional Situations====

None.

====See Also====

**[[CL:Macros:cond]]**, **[[CL:Functions:every]]**, \specref{if}, **[[CL:Macros:or]]**, **[[CL:Macros:when]]**

====Notes====

<blockquote> (and //form//) ≡ (let () //form//) (and //form1// //form2// ...) ≡ (when //form1// (and //form2// ...)) </blockquote>

