====== Function BOOLE ======

====Syntax====

**boole** //op integer-1 integer-2// → //result-integer//

====Arguments and Values====

//Op// - a //[[CL:Glossary:bit-wise logical operation specifier]]//.

//integer-1// - an //[[CL:Glossary:integer]]//.

//integer-2// - an //[[CL:Glossary:integer]]//.

//result-integer// - an //[[CL:Glossary:integer]]//.

====Description====

**[[CL:Functions:boole]]** performs bit-wise logical operations on //integer-1// and //integer-2//, which are treated as if they were binary and in two's complement representation.

The operation to be performed and the return value are determined by //op//.

**[[CL:Functions:boole]]** returns the values specified for any //op// in \thenextfigure.

{ \def\zz{0\ \ \ 0} \def\ww{1\ \ \ 1} \def\zw{0\ \ \ 1} \def\wz{1\ \ \ 0} \def\sp{\ \ \ }

\tablefigtwo{Bit-Wise Logical Operations}{Op}{Result}{ **[[CL:Variables:boole-1]]** & //integer-1// \cr **[[CL:Variables:boole-2]]** & //integer-2// \cr **[[CL:Variables:boole-andc1]]** & and complement of //integer-1// with //integer-2// \cr **[[CL:Variables:boole-andc2]]** & and //integer-1// with complement of //integer-2// \cr **[[CL:Variables:boole-and]]** & and \cr **[[CL:Variables:boole-c1]]** & complement of //integer-1// \cr **[[CL:Variables:boole-c2]]** & complement of //integer-2// \cr **[[CL:Variables:boole-clr]]** & always 0 (all zero bits) \cr **[[CL:Variables:boole-eqv]]** & equivalence (exclusive nor) \cr **[[CL:Variables:boole-ior]]** & inclusive or \cr **[[CL:Variables:boole-nand]]** & not-and \cr **[[CL:Variables:boole-nor]]** & not-or \cr **[[CL:Variables:boole-orc1]]** & or complement of //integer-1// with //integer-2// \cr **[[CL:Variables:boole-orc2]]** & or //integer-1// with complement of //integer-2// \cr **[[CL:Variables:boole-set]]** & always -1 (all one bits) \cr **[[CL:Variables:boole-xor]]** & exclusive or \cr } }

====Examples====

<blockquote> (boole boole-ior 1 16) → 17 (boole boole-and -2 5) → 4 (boole boole-eqv 17 15) → -31

;;; These examples illustrate the result of applying BOOLE and each ;;; of the possible values of OP to each possible combination of bits. (progn (format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~ ~ (dolist (symbol '(boole-1 boole-2 boole-and boole-andc1 boole-andc2 boole-c1 boole-c2 boole-clr boole-eqv boole-ior boole-nand boole-nor boole-orc1 boole-orc2 boole-set boole-xor)) (let ((result (boole (symbol-value symbol) #b0011 #b0101))) (format t "~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~ symbol result (logand result #b1111)))))
▷ Results of (BOOLE <op> #b0011 #b0101) ...
▷ ---Op-------Decimal-----Binary----Bits---
▷ BOOLE-1 3 11 ...0011
▷ BOOLE-2 5 101 ...0101
▷ BOOLE-AND 1 1 ...0001
▷ BOOLE-ANDC1 4 100 ...0100
▷ BOOLE-ANDC2 2 10 ...0010
▷ BOOLE-C1 -4 -100 ...1100
▷ BOOLE-C2 -6 -110 ...1010
▷ BOOLE-CLR 0 0 ...0000
▷ BOOLE-EQV -7 -111 ...1001
▷ BOOLE-IOR 7 111 ...0111
▷ BOOLE-NAND -2 -10 ...1110
▷ BOOLE-NOR -8 -1000 ...1000
▷ BOOLE-ORC1 -3 -11 ...1101
▷ BOOLE-ORC2 -5 -101 ...1011
▷ BOOLE-SET -1 -1 ...1111
▷ BOOLE-XOR 6 110 ...0110 → NIL </blockquote>

====Affected By====

None.

====Exceptional Situations====

Should signal **[[CL:Types:type-error]]** if its first argument is not a //[[CL:Glossary:bit-wise logical operation specifier]]// or if any subsequent argument is not an //[[CL:Glossary:integer]]//.

====See Also====

**[[CL:Functions:logand]]**

====Notes====

In general,

<blockquote> (boole boole-and x y) ≡ (logand x y) </blockquote>

//[[CL:Glossary:Programmers]]// who would prefer to use numeric indices rather than //[[CL:Glossary:bit-wise logical operation specifiers]]// can get an equivalent effect by a technique such as the following:

<blockquote> ;; The order of the values in this `table' are such that ;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n (defconstant boole-n-vector (vector boole-clr boole-and boole-andc1 boole-2 boole-andc2 boole-1 boole-xor boole-ior boole-nor boole-eqv boole-c1 boole-orc1 boole-c2 boole-orc2 boole-nand boole-set)) → BOOLE-N-VECTOR (proclaim '(inline boole-n)) → //[[CL:Glossary:implementation-dependent]]// (defun boole-n (n integer &rest more-integers) (apply #'boole (elt boole-n-vector n) integer more-integers)) → BOOLE-N (boole-n #b0111 5 3) → 7 (boole-n #b0001 5 3) → 1 (boole-n #b1101 5 3) → -3 (loop for n from #b0000 to #b1111 collect (boole-n n 5 3)) → (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1) </blockquote>

