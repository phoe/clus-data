### Very hard to check, better wait to solve ":" problem
### +++ CLUS
### --- CLHS

--- saved-pages-dpans3/cl:macros:loop.txt	2017-04-27 21:54:31.000000000 +0100
+++ saved-pages-clus/cl:macros:loop.txt	2017-04-27 21:54:32.000000000 +0100
@@ -1,23 +1,51 @@
 Macro LOOP

 Syntax

-The ``simple'' loop form

-loop compound-form* => result*
+ The "simple" loop form

-The ``extended'' loop form
+ loop compound-form* → result*

-loop [name-clause] {variable-clause}* {main-clause}* => result*


-name-clause= named name
+ The "extended" loop form

+ loop [name-clause] {variable-clause}* {main-clause}* → result*

-variable-clause= with-clause | initial-final | for-as-clause


-with-clause= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}*


+name-clause = named name
### CLHS "name-clause=" CLUS "name-clause ="
+variable-clause = with-clause | initial-final | for-as-clause
### CLHS "variable-clause=" CLUS "variable-clause ="
+with-clause = with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}*
 main-clause= unconditional | accumulation | conditional | termination-test | initial-final
+initial-final = initially compound-form+ | finally compound-form+unconditional = {do | doing} compound-form+ | return {form | it}
+accumulation = list-accumulation | numeric-accumulation
+list-accumulation = {collect | collecting | append | appending | nconc | nconcing} {form | it} [into simple-var]
+numeric-accumulation = {count | counting | sum | summing | maximize | maximizing | minimize | minimizing} {form | it} [into simple-var] [type-spec]
+conditional = {if | when | unless} form selectable-clause {and selectable-clause}* [else selectable-clause {and selectable-clause}*] [end]
+selectable-clause = unconditional | accumulation | conditional
+termination-test = while form | until form | repeat form | always form | never form | thereis form
+for-as-clause = {for | as} for-as-subclause {and for-as-subclause}*
+for-as-subclause = for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then |for-as-across | for-as-hash | for-as-package
+for-as-arithmetic = var [type-spec] for-as-arithmetic-subclause
+for-as-arithmetic-subclause = arithmetic-up | arithmetic-downto | arithmetic-downfrom
+arithmetic-up = ⟦{from | upfrom} form1 | {to | upto | below} form2 |  form3⟧+arithmetic-downto = ⟦ {from form1}1 | {{downto | above} form2}1 |  form3 ⟧
+arithmetic-downfrom = ⟦ {downfrom form1}1 | {to | downto | above} form2 |  form3 ⟧
+for-as-in-list = var [type-spec] in form1 [by step-fun]
+for-as-on-list = var [type-spec] on form1 [by step-fun]
+for-as-equals-then = var [type-spec] = form1 [then form2]
+for-as-across = var [type-spec] across vector
+for-as-hash = var [type-spec] being {each | the} {{hash-key | hash-keys} {in | of} hash-table [using (hash-value other-var)] | {hash-value | hash-values} {in | of} hash-table [using (hash-key other-var)]}
+for-as-package = var [type-spec] being {each | the} {symbol | symbols | present-symbol | present-symbols | external-symbol | external-symbols} [{in | of} package]
+type-spec = simple-type-spec | destructured-type-spec
+simple-type-spec = fixnum | float | t | nil
+destructured-type-spec = of-type d-type-spec
+d-type-spec = type-specifier | (d-type-spec . d-type-spec)
+var = d-var-spec
+var1 = d-var-spec
+var2 = d-var-spec
+other-var = d-var-spec
+d-var-spec = simple-var | nil | (d-var-spec . d-var-spec)


-initial-final= initially compound-form+ | finally compound-form+

+Arguments and Values

-unconditional= {do | doing} compound-form+ | return {form | it}

+ compound-form - a compound form.

-accumulation= list-accumulation | numeric-accumulation
+ name - a symbol.

+ simple-var - a symbol (a variable name).

-list-accumulation= {collect | collecting | append | appending | nconc | nconcing} {form | it}
-                     [into simple-var]
+ form, form1, form2, form3 - a form.

+ step-fun - a form that evaluates to a function of one argument.

-numeric-accumulation= {count | counting | sum | summing | }
-                         maximize | maximizing | minimize | minimizing {form | it}
-                        [into simple-var] [type-spec]
+ vector - a form that evaluates to a vector.

+ hash-table - a form that evaluates to a hash table.

-conditional= {if | when | unless} form selectable-clause {and selectable-clause}*
-               [else selectable-clause {and selectable-clause}*]
-               [end]
+ package - a form that evaluates to a package designator.

+ type-specifier - a type specifier. This might be either an atomic type specifier or a compound type specifier, which introduces some additional complications to proper parsing in the face of destructuring; for further information, see section {\secref\DestructuringLOOPVars}.

-selectable-clause= unconditional | accumulation | conditional
+ result - an object.


-termination-test= while form | until form | repeat form | always form | never form | thereis form

+Description

-for-as-clause= {for | as} for-as-subclause {and for-as-subclause}*

+For details, see section {\secref\LoopFacility}.

-for-as-subclause= for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then |
-                    for-as-across | for-as-hash | for-as-package

+Examples

-for-as-arithmetic= var [type-spec] for-as-arithmetic-subclause

+An example of the simple form of loop.

-for-as-arithmetic-subclause= arithmetic-up | arithmetic-downto | arithmetic-downfrom


-arithmetic-up= [[{from | upfrom} form1 |   {to | upto | below} form2 |   by form3]]+
+(defun sqrt-advisor ()
+  (loop
+    (format t "~&Number ")
+    (let ((n (parse-integer (read-line) junk-allowed t)))
+      (when (not n)
+        (return))
+      (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))

+→

-arithmetic-downto= [[{{from form1}}1  |   {{{downto | above} form2}}1  |   by form3]]
+SQRT-ADVISOR


-arithmetic-downfrom= [[{{downfrom form1}}1  |   {to | downto | above} form2 |   by form3]]

+(sqrt-advisor)

-for-as-in-list= var [type-spec] in form1 [by step-fun]
+▷

+Number 5
+The square root of 5 is 2.236068.
+Number 4
+The square root of 4 is 2.
+Number done

-for-as-on-list= var [type-spec] on form1 [by step-fun]
+→

+NIL

-for-as-equals-then= var [type-spec] = form1 [then form2]


-for-as-across= var [type-spec] across vector
+Two examples of the extended form of LOOP.


-for-as-hash= var [type-spec] being {each | the}
-               {{hash-key | hash-keys} {in | of} hash-table
-                [using (hash-value other-var)] |
-                {hash-value | hash-values} {in | of} hash-table
-                [using (hash-key other-var)]}

+(defun square-advisor ()
+  (loop as n = (progn (format t "~&Number ")
+                      (parse-integer (read-line) junk-allowed t))
+        while n
+          do (format t "~&The square of ~D is ~D.~%" n (* n n))))

-for-as-package= var [type-spec] being {each | the}
-                  {symbol | symbols |
-                   present-symbol | present-symbols |
-                   external-symbol | external-symbols}
-                  [{in | of} package]
+→

+SQUARE-ADVISOR

-type-spec= simple-type-spec | destructured-type-spec


-simple-type-spec= fixnum | float | t | nil
+(square-advisor)

+▷

-destructured-type-spec= of-type d-type-spec
+Number 4
+The square of 4 is 16.
+Number 23
+The square of 23 is 529.
+Number done

+→

-d-type-spec= type-specifier | (d-type-spec . d-type-spec)
+NIL


-var= d-var-spec

+(loop for n from 1 to 10
+      when (oddp n) collect n)

-var1= d-var-spec
+→

+(1 3 5 7 9)

-var2= d-var-spec


-other-var= d-var-spec
+Affected By


-d-var-spec= simple-var | nil | (d-var-spec . d-var-spec)
+None.


-Arguments and Values
+Exceptional Situations

-compound-form - a compound form.
-name - a symbol.
-simple-var - a symbol (a variable name).
-form, form1, form2, form3 - a form.
- step-fun - a form that evaluates to a function of one argument.
-vector - a form that evaluates to a vector.
-hash-table - a form that evaluates to a hash table.
-package - a form that evaluates to a package designator.
-type-specifier - a type specifier. This might be either an atomic type specifier or a compound type specifier, which introduces some additional complications to proper parsing in the face of destructuring; for further information, see Section 6.1.1.7 (Destructuring).
-result - an object.

-Description
+None.

-For details, see Section 6.1 (The LOOP Facility).
-Examples

+See Also

-;; An example of the simple form of LOOP.
- (defun sqrt-advisor ()
-   (loop (format t "~&Number ")
-         (let ((n (parse-integer (read-line) junk-allowed t)))
-           (when (not n) (return))
-           (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))
-=>  SQRT-ADVISOR
- (sqrt-advisor)
->>  Number 5<NEWLINE>
->>  The square root of 5 is 2.236068.
->>  Number 4<NEWLINE>
->>  The square root of 4 is 2.
->>  Number done<NEWLINE>
-=>  NIL

-;; An example of the extended form of LOOP.
- (defun square-advisor ()
-   (loop as n = (progn (format t "~&Number ")
-                       (parse-integer (read-line) junk-allowed t))
-         while n
-         do (format t "~&The square of ~D is ~D.~%" n (* n n))))
-=>  SQUARE-ADVISOR
- (square-advisor)
->>  Number 4<NEWLINE>
->>  The square of 4 is 16.
->>  Number 23<NEWLINE>
->>  The square of 23 is 529.
->>  Number done<NEWLINE>
-=>  NIL
+ Macro DO

-;; Another example of the extended form of LOOP.
- (loop for n from 1 to 10
-       when (oddp n)
-         collect n)
-=>  (1 3 5 7 9)
+ Macro DOLIST

-<TT>
-Affected By None.
+ Macro DOTIMES
+ Macro RETURN
+ Special Operator GO
+ Special Operator THROW
+ {\secref\DestructuringLOOPVars}

-Exceptional Situations None.

-See Also

-do, dolist, dotimes, return, go, throw, Section 6.1.1.7 (Destructuring)
 Notes

 Except that loop-finish cannot be used within a simple loop form, a simple loop form is related to an extended loop form in the following way

- (loop compound-form*) ==  (loop do compound-form*)

-<TT>
-The following X3J13 cleanup issues, not part of the specification, apply to this section LOOP-MISCELLANEOUS-REPAIRSFIX LOOP-SYNTAX-OVERHAULREPAIR
\ No newline at end of file
+(loop compound-form*) ≡ (loop do compound-form*)
+\
\ No newline at end of file
