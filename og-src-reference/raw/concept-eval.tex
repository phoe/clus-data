

//[[CL:Glossary:Execution]]// of //[[CL:Glossary:code]]// can be accomplished by a variety of means ranging from direct interpretation of a //[[CL:Glossary:form]]// representing a //[[CL:Glossary:program]]// to invocation of //[[CL:Glossary:compiled code]]// produced by a //[[CL:Glossary:compiler]]//.
  \newtermidx{Evaluation}{evaluation} is the process by which a //[[CL:Glossary:program]]// is //[[CL:Glossary:executed]]// in \clisp. The mechanism of //[[CL:Glossary:evaluation]]// is manifested
 both implicitly through the effect of the //[[CL:Glossary:Lisp read-eval-print loop]]//,
 and  explicitly through the presence of the //[[CL:Glossary:functions]]// 
       **[[CL:Functions:eval]]**,
       **[[CL:Functions:compile]]**,
       **[[CL:Functions:compile-file]]**,
   and **[[CL:Functions:load]]**. Any of these facilities might share the same execution strategy,  or each might use a different one.

The behavior of a //[[CL:Glossary:conforming program]]// processed by **[[CL:Functions:eval]]** and by **[[CL:Functions:compile-file]]** might differ; \seesection\SemanticConstraints.

//[[CL:Glossary:Evaluation]]// can be understood in terms of a model in which an interpreter recursively traverses a //[[CL:Glossary:form]]// performing each step of the computation as it goes.   This model, which describes the semantics of \clisp\ //[[CL:Glossary:programs]]//, is described in \secref\EvaluationModel.

\beginsubSection{Introduction to Environments} \DefineSection{IntroToEnvs}

A //[[CL:Glossary:binding]]// is an association between a //[[CL:Glossary:name]]// and that which the name denotes.  //[[CL:Glossary:Bindings]]// are //[[CL:Glossary:established]]// in a //[[CL:Glossary:lexical environment]]// or a //[[CL:Glossary:dynamic environment]]// by particular //[[CL:Glossary:special operators]]//.

An //[[CL:Glossary:environment]]// is a set of //[[CL:Glossary:bindings]]// and other information used during evaluation (\eg to associate meanings with names).

//[[CL:Glossary:Bindings]]// in an //[[CL:Glossary:environment]]// are partitioned into \newtermidx{namespaces}{namespace}. A single //[[CL:Glossary:name]]// can simultaneously have more than one associated //[[CL:Glossary:binding]]// per //[[CL:Glossary:environment]]//, but can have only one associated //[[CL:Glossary:binding]]// per //[[CL:Glossary:namespace]]//.

\beginsubsubsection{The Global Environment}

The //[[CL:Glossary:global environment]]// is that part of an //[[CL:Glossary:environment]]// that contains //[[CL:Glossary:bindings]]// with both //[[CL:Glossary:indefinite scope]]//  and //[[CL:Glossary:indefinite extent]]//. The //[[CL:Glossary:global environment]]// contains, among other things, the following:

\beginlist \item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:dynamic variables]]// and //[[CL:Glossary:constant variables]]//. \item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:functions]]//, //[[CL:Glossary:macros]]//, and //[[CL:Glossary:special operators]]//. \item{\bull}% \issue{DEFINE-COMPILER-MACRO:X3J13-NOV89}%
 //[[CL:Glossary:bindings]]// of //[[CL:Glossary:compiler macros]]//.

\item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:type]]// and //[[CL:Glossary:class]]// //[[CL:Glossary:names]]// \item{\bull} information about //[[CL:Glossary:proclamations]]//. \endlist

\endsubsubsection%{The Global Environment}

\beginsubsubsection{Dynamic Environments}

A //[[CL:Glossary:dynamic environment]]// for //[[CL:Glossary:evaluation]]// is that part of an //[[CL:Glossary:environment]]// that contains //[[CL:Glossary:bindings]]// whose duration is bounded by points of //[[CL:Glossary:establishment]]// and //[[CL:Glossary:disestablishment]]//  within the execution of the //[[CL:Glossary:form]]// that established the //[[CL:Glossary:binding]]//. A //[[CL:Glossary:dynamic environment]]// contains, among other things, the following:

\beginlist \item{\bull} //[[CL:Glossary:bindings]]// for //[[CL:Glossary:dynamic variables]]//. \item{\bull} information about //[[CL:Glossary:active]]// //[[CL:Glossary:catch tags]]//. \item{\bull} information about //[[CL:Glossary:exit points]]// established by \specref{unwind-protect}. \item{\bull} information about //[[CL:Glossary:active]]// //[[CL:Glossary:handlers]]// and //[[CL:Glossary:restarts]]//. \endlist

The //[[CL:Glossary:dynamic environment]]// that is active at any given point  in the //[[CL:Glossary:execution]]// of a //[[CL:Glossary:program]]// is referred to by  definite reference as ``the current //[[CL:Glossary:dynamic environment]]//,'' or sometimes as just ``the //[[CL:Glossary:dynamic environment]]//.''

Within a given //[[CL:Glossary:namespace]]//, a //[[CL:Glossary:name]]// is said to be //[[CL:Glossary:bound]]// in a //[[CL:Glossary:dynamic environment]]// if there is a //[[CL:Glossary:binding]]// 

associated with its //[[CL:Glossary:name]]// in the //[[CL:Glossary:dynamic environment]]//  or, if not, there is a //[[CL:Glossary:binding]]// 

associated with its name in the //[[CL:Glossary:global environment]]//.

\endsubsubsection%{Dynamic Environments}

\beginsubsubsection{Lexical Environments}

A //[[CL:Glossary:lexical environment]]// for //[[CL:Glossary:evaluation]]// at some position in a //[[CL:Glossary:program]]// is that part of the //[[CL:Glossary:environment]]// that contains information having  //[[CL:Glossary:lexical scope]]// within the //[[CL:Glossary:forms]]// containing that position. A //[[CL:Glossary:lexical environment]]// contains, among other things, the following:

\beginlist \item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:lexical variables]]// and //[[CL:Glossary:symbol macros]]//. \item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:functions]]// and //[[CL:Glossary:macros]]//.
             (Implicit in this is information about those //[[CL:Glossary:compiler macros]]//  	      that are locally disabled.)

\item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:block tags]]//. \item{\bull} //[[CL:Glossary:bindings]]// of //[[CL:Glossary:go tags]]//. \item{\bull} information about //[[CL:Glossary:declarations]]//. \endlist

The //[[CL:Glossary:lexical environment]]// that is active at any given position in a //[[CL:Glossary:program]]// being semantically processed is referred to by definite reference as ``the current //[[CL:Glossary:lexical environment]]//,'' or sometimes as just ``the //[[CL:Glossary:lexical environment]]//.''  

Within a given //[[CL:Glossary:namespace]]//, a //[[CL:Glossary:name]]// is said to be //[[CL:Glossary:bound]]// in a //[[CL:Glossary:lexical environment]]// if there is a //[[CL:Glossary:binding]]// 

associated with its //[[CL:Glossary:name]]// in the //[[CL:Glossary:lexical environment]]// or, if not, there is a //[[CL:Glossary:binding]]// 

associated with its name in the //[[CL:Glossary:global environment]]//.

\beginsubsubsubsection{The Null Lexical Environment} \DefineSection{NullLexicalEnv}

The //[[CL:Glossary:null lexical environment]]// is equivalent to the //[[CL:Glossary:global environment]]//.

Although in general the representation of an //[[CL:Glossary:environment]]// //[[CL:Glossary:object]]// is //[[CL:Glossary:implementation-dependent]]//, \nil\ can be used in any situation where an //[[CL:Glossary:environment]]// //[[CL:Glossary:object]]// is called for in order to denote  the //[[CL:Glossary:null lexical environment]]//.

\endsubsubsubsection%{The Null Lexical Environment}

\endsubsubsection%{Lexical Environments}

\beginsubsubsection{Environment Objects} \DefineSection{EnvObjs}

Some //[[CL:Glossary:operators]]// make use of an //[[CL:Glossary:object]]//,  called an //[[CL:Glossary:environment object]]//, that represents the set of //[[CL:Glossary:lexical bindings]]// needed to perform semantic analysis on a //[[CL:Glossary:form]]// in a given //[[CL:Glossary:lexical environment]]//. The set of //[[CL:Glossary:bindings]]// in an //[[CL:Glossary:environment object]]// may be a subset of the //[[CL:Glossary:bindings]]// that would be needed to actually  perform an //[[CL:Glossary:evaluation]]//; for example, //[[CL:Glossary:values]]// associated with //[[CL:Glossary:variable]]// //[[CL:Glossary:names]]// and //[[CL:Glossary:function names]]// in the corresponding //[[CL:Glossary:lexical environment]]// might not be available in an //[[CL:Glossary:environment object]]//.

The //[[CL:Glossary:type]]// and nature of an //[[CL:Glossary:environment object]]// is //[[CL:Glossary:implementation-dependent]]//. The //[[CL:Glossary:values]]// of //[[CL:Glossary:environment parameters]]// to //[[CL:Glossary:macro functions]]// are examples of //[[CL:Glossary:environment objects]]//.

The //[[CL:Glossary:object]]// \nil\ when used as an //[[CL:Glossary:environment object]]// denotes the //[[CL:Glossary:null lexical environment]]//; \seesection\NullLexicalEnv.

\endsubsubsection%{Environment Objects}

\endSubsection%{Introduction to Environments}

\beginSubsection{The Evaluation Model} \DefineSection{EvaluationModel}

A \clisp\ system evaluates //[[CL:Glossary:forms]]// with respect to lexical, dynamic, and global //[[CL:Glossary:environments]]//.  The following sections describe the components of the \clisp\ evaluation model.

\beginsubsubsection{Form Evaluation}

//[[CL:Glossary:Forms]]// fall into three categories:

//[[CL:Glossary:symbols]]//, //[[CL:Glossary:conses]]//, and //[[CL:Glossary:self-evaluating objects]]//. The following sections explain these categories.
                                             \beginsubsubsubsection{Symbols as Forms} \DefineSection{SymbolsAsForms}

If a //[[CL:Glossary:form]]// is a //[[CL:Glossary:symbol]]//, then it is either a //[[CL:Glossary:symbol macro]]// or a //[[CL:Glossary:variable]]//.

The //[[CL:Glossary:symbol]]// names a //[[CL:Glossary:symbol macro]]//  if there is a //[[CL:Glossary:binding]]// of the //[[CL:Glossary:symbol]]// as a //[[CL:Glossary:symbol macro]]// in the current //[[CL:Glossary:lexical environment]]//  \issue{ISO-COMPATIBILITY:ADD-SUBSTRATE}
 (see \macref{define-symbol-macro} and \specref{symbol-macrolet}).

If the //[[CL:Glossary:symbol]]// is a //[[CL:Glossary:symbol macro]]//, its expansion function is obtained. The expansion function is a function of two arguments, and is invoked by calling the //[[CL:Glossary:macroexpand hook]]// with 
     the expansion function as its first argument,
     the //[[CL:Glossary:symbol]]// as its second argument,
 and an //[[CL:Glossary:environment object]]// (corresponding to the current //[[CL:Glossary:lexical environment]]//)
      as its third argument. The //[[CL:Glossary:macroexpand hook]]//, in turn, calls the expansion function with the //[[CL:Glossary:form]]// as its first argument and the //[[CL:Glossary:environment]]// as its second argument. The //[[CL:Glossary:value]]// of the expansion function, which is passed through by the //[[CL:Glossary:macroexpand hook]]//, is a //[[CL:Glossary:form]]//.  This resulting //[[CL:Glossary:form]]// is processed in place of the original //[[CL:Glossary:symbol]]//.

If a //[[CL:Glossary:form]]// is a //[[CL:Glossary:symbol]]// that is not a //[[CL:Glossary:symbol macro]]//, then it is the //[[CL:Glossary:name]]// of a //[[CL:Glossary:variable]]//, and the //[[CL:Glossary:value]]// of that //[[CL:Glossary:variable]]// is returned. There are three kinds of variables:
 //[[CL:Glossary:lexical variables]]//,
 //[[CL:Glossary:dynamic variables]]//, and
 //[[CL:Glossary:constant variables]]//.

A //[[CL:Glossary:variable]]// can store one //[[CL:Glossary:object]]//. The main operations on a //[[CL:Glossary:variable]]// are 
 to //[[CL:Glossary:read]]//\meaning{1} and 
 to //[[CL:Glossary:write]]//\meaning{1} its //[[CL:Glossary:value]]//.

An error \oftype{unbound-variable} should be signaled if an //[[CL:Glossary:unbound variable]]// is referenced.

//[[CL:Glossary:Non-constant variables]]// can be //[[CL:Glossary:assigned]]// by using \specref{setq}  or //[[CL:Glossary:bound]]//\meaning{3} by using \specref{let}. \Thenextfigure\ lists some //[[CL:Glossary:defined names]]// that are applicable to assigning, binding, and defining //[[CL:Glossary:variables]]//.

\displaythree{Some Defined Names Applicable to Variables}{ boundp&let&progv\cr defconstant&let*&psetq\cr defparameter&makunbound&set\cr defvar&multiple-value-bind&setq\cr lambda&multiple-value-setq&symbol-value\cr }

The following is a description of each kind of variable.

\beginsubsubsubsubsection{Lexical Variables}

A //[[CL:Glossary:lexical variable]]// is a //[[CL:Glossary:variable]]// that can be referenced only within  the //[[CL:Glossary:lexical scope]]// of the //[[CL:Glossary:form]]// that establishes that //[[CL:Glossary:variable]]//; //[[CL:Glossary:lexical variables]]// have //[[CL:Glossary:lexical scope]]//. Each time a //[[CL:Glossary:form]]// creates a //[[CL:Glossary:lexical binding]]// of a //[[CL:Glossary:variable]]//, a //[[CL:Glossary:fresh]]// //[[CL:Glossary:binding]]// is //[[CL:Glossary:established]]//.

Within the //[[CL:Glossary:scope]]// of a //[[CL:Glossary:binding]]// for a //[[CL:Glossary:lexical variable]]// //[[CL:Glossary:name]]//, uses of that //[[CL:Glossary:name]]// as a //[[CL:Glossary:variable]]// are considered to be references to that //[[CL:Glossary:binding]]// except where the //[[CL:Glossary:variable]]// is //[[CL:Glossary:shadowed]]//\meaning{2}  by a //[[CL:Glossary:form]]// that //[[CL:Glossary:establishes]]// a //[[CL:Glossary:fresh]]// //[[CL:Glossary:binding]]// for that  //[[CL:Glossary:variable]]// //[[CL:Glossary:name]]//, or by a //[[CL:Glossary:form]]// that locally //[[CL:Glossary:declares]]// the //[[CL:Glossary:name]]// **[[CL:Declarations:special]]**.

A //[[CL:Glossary:lexical variable]]// always has a //[[CL:Glossary:value]]//. There is no //[[CL:Glossary:operator]]// that introduces a //[[CL:Glossary:binding]]// for a //[[CL:Glossary:lexical variable]]// without giving it an initial //[[CL:Glossary:value]]//, nor is there any //[[CL:Glossary:operator]]// that can make a //[[CL:Glossary:lexical variable]]// be //[[CL:Glossary:unbound]]//.

//[[CL:Glossary:Bindings]]// of //[[CL:Glossary:lexical variables]]// are found in the //[[CL:Glossary:lexical environment]]//.

\endsubsubsubsubsection%{Lexical Variables}

\beginsubsubsubsubsection{Dynamic Variables}

A //[[CL:Glossary:variable]]// is a //[[CL:Glossary:dynamic variable]]// if one of the following conditions hold:

\beginlist

 \item{\bull} It is locally declared or globally proclaimed **[[CL:Declarations:special]]**.

 \item{\bull} It occurs textually within a //[[CL:Glossary:form]]// that creates a //[[CL:Glossary:dynamic binding]]// for a //[[CL:Glossary:variable]]// of the //[[CL:Glossary:same]]// //[[CL:Glossary:name]]//, and the //[[CL:Glossary:binding]]// is not //[[CL:Glossary:shadowed]]//\meaning{2} by a //[[CL:Glossary:form]]// that creates a //[[CL:Glossary:lexical binding]]// of the same //[[CL:Glossary:variable]]// //[[CL:Glossary:name]]//.

\endlist

A //[[CL:Glossary:dynamic variable]]// can be referenced at any time in any //[[CL:Glossary:program]]//; there is no textual limitation on references to //[[CL:Glossary:dynamic variables]]//. At any given time, all //[[CL:Glossary:dynamic variables]]// with a given name refer to  exactly one //[[CL:Glossary:binding]]//, either in the //[[CL:Glossary:dynamic environment]]// or in the //[[CL:Glossary:global environment]]//.

The //[[CL:Glossary:value]]// part of the //[[CL:Glossary:binding]]// for a //[[CL:Glossary:dynamic variable]]// might be empty; in this case, the //[[CL:Glossary:dynamic variable]]// is said to have no //[[CL:Glossary:value]]//, or to be //[[CL:Glossary:unbound]]//.  A //[[CL:Glossary:dynamic variable]]// can be made //[[CL:Glossary:unbound]]// by using **[[CL:Functions:makunbound]]**.
            The effect of //[[CL:Glossary:binding]]// a //[[CL:Glossary:dynamic variable]]// is to create a new //[[CL:Glossary:binding]]// to which all references to that //[[CL:Glossary:dynamic variable]]// in any //[[CL:Glossary:program]]// refer for the duration of the //[[CL:Glossary:evaluation]]// of the //[[CL:Glossary:form]]// that creates the //[[CL:Glossary:dynamic binding]]//.

A //[[CL:Glossary:dynamic variable]]// can be referenced outside the //[[CL:Glossary:dynamic extent]]// of a //[[CL:Glossary:form]]// that //[[CL:Glossary:binds]]// it.  Such a //[[CL:Glossary:variable]]// is sometimes called  a ``global variable'' but is still in all respects just a //[[CL:Glossary:dynamic variable]]// whose //[[CL:Glossary:binding]]// happens to exist in the //[[CL:Glossary:global environment]]// rather than in some //[[CL:Glossary:dynamic environment]]//.

A //[[CL:Glossary:dynamic variable]]// is //[[CL:Glossary:unbound]]// unless and until explicitly assigned a value, except for  those variables whose initial value is  defined in this specification or by an //[[CL:Glossary:implementation]]//.

\endsubsubsubsubsection%{Dynamic Variables}

\beginsubsubsubsubsection{Constant Variables} \DefineSection{ConstantVars}

Certain variables, called //[[CL:Glossary:constant variables]]//, are reserved as ``named constants.''   The consequences are undefined if an attempt is made to 
    assign a value to,
 or create a //[[CL:Glossary:binding]]// for a //[[CL:Glossary:constant variable]]//,  except that a `compatible' redefinition of a //[[CL:Glossary:constant variable]]// using \macref{defconstant} is permitted; \seemac{defconstant}.

//[[CL:Glossary:Keywords]]//,  //[[CL:Glossary:symbols]]// defined by \clisp\ or the //[[CL:Glossary:implementation]]//
  as constant (such as \nil, \t, and \conref{pi}), and //[[CL:Glossary:symbols]]// declared as constant using \macref{defconstant} are //[[CL:Glossary:constant variables]]//.

\endsubsubsubsubsection%{Constant Variables}

\beginsubsubsubsubsection{Symbols Naming Both Lexical and Dynamic Variables}

The same //[[CL:Glossary:symbol]]// can name both 
    a //[[CL:Glossary:lexical variable]]//  and a //[[CL:Glossary:dynamic variable]]//, but never in the same //[[CL:Glossary:lexical environment]]//.

In the following example, the //[[CL:Glossary:symbol]]// \f{x} is used, at different times, 
    as the //[[CL:Glossary:name]]// of a //[[CL:Glossary:lexical variable]]// and as the //[[CL:Glossary:name]]// of a //[[CL:Glossary:dynamic variable]]//.
  \code
 (let ((x 1))            ;Binds a special variable X
   (declare (special x))
   (let ((x 2))          ;Binds a lexical variable X
     (+ x                ;Reads a lexical variable X
        (locally (declare (special x))
                 x))))   ;Reads a special variable X \EV 3 \endcode

\endsubsubsubsubsection%{Symbols Naming Both Lexical and Dynamic Variables}

\endsubsubsubsection%{Symbols as Forms}

\beginsubsubsubsection{Conses as Forms}

A //[[CL:Glossary:cons]]// that is used as a //[[CL:Glossary:form]]// is called a //[[CL:Glossary:compound form]]//.

If the //[[CL:Glossary:car]]// of that //[[CL:Glossary:compound form]]// is a //[[CL:Glossary:symbol]]//,  that //[[CL:Glossary:symbol]]// is the //[[CL:Glossary:name]]// of an //[[CL:Glossary:operator]]//, and the //[[CL:Glossary:form]]// is either a //[[CL:Glossary:special form]]//, a //[[CL:Glossary:macro form]]//, or a //[[CL:Glossary:function form]]//, depending on the //[[CL:Glossary:function]]// //[[CL:Glossary:binding]]//  of the //[[CL:Glossary:operator]]// in the current //[[CL:Glossary:lexical environment]]//. If the //[[CL:Glossary:operator]]// is neither a //[[CL:Glossary:special operator]]// nor a //[[CL:Glossary:macro name]]//, it is assumed to be a //[[CL:Glossary:function name]]// (even if there is no definition for such a //[[CL:Glossary:function]]//).

If the //[[CL:Glossary:car]]// of the //[[CL:Glossary:compound form]]// is not a //[[CL:Glossary:symbol]]//, then that //[[CL:Glossary:car]]// must be a //[[CL:Glossary:lambda expression]]//, in which case the //[[CL:Glossary:compound form]]// is a //[[CL:Glossary:lambda form]]//.

How a //[[CL:Glossary:compound form]]// is processed depends on whether it is  classified as a //[[CL:Glossary:special form]]//, a //[[CL:Glossary:macro form]]//,  a //[[CL:Glossary:function form]]//, or a //[[CL:Glossary:lambda form]]//.

\beginsubsubsubsubsection{Special Forms}

A //[[CL:Glossary:special form]]// is a //[[CL:Glossary:form]]// with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both.

A //[[CL:Glossary:special operator]]// has access to
    the current //[[CL:Glossary:lexical environment]]//  and the current //[[CL:Glossary:dynamic environment]]//. Each //[[CL:Glossary:special operator]]// defines the manner in which its //[[CL:Glossary:subexpressions]]// are treated---which are //[[CL:Glossary:forms]]//, which are special syntax, \etc.

Some //[[CL:Glossary:special operators]]// create new  lexical or dynamic //[[CL:Glossary:environments]]// for use during the  //[[CL:Glossary:evaluation]]// of //[[CL:Glossary:subforms]]// of the //[[CL:Glossary:special form]]//.  For example, \specref{block} creates a new //[[CL:Glossary:lexical environment]]// that is the same as the one in force at the point of evaluation of the \specref{block} //[[CL:Glossary:form]]// with the addition of a //[[CL:Glossary:binding]]// of the \specref{block} name to an //[[CL:Glossary:exit point]]// from the \specref{block}.

The set of //[[CL:Glossary:special operator]]// //[[CL:Glossary:names]]// is fixed in \clisp;  no way is provided for the user to define a //[[CL:Glossary:special operator]]//. \Thenextfigure\ lists all of the \clisp\ //[[CL:Glossary:symbols]]// that have definitions as //[[CL:Glossary:special operators]]//.

\DefineFigure{CLSpecialOps}

\issue{COMPILER-LET-CONFUSION:ELIMINATE} \issue{WITH-ADDED-METHODS:DELETE} \issue{LOAD-TIME-EVAL:R**2-NEW-SPECIAL-FORM} \issue{GENERIC-FLET-POORLY-DESIGNED:DELETE} \displaythree{Common Lisp Special Operators}{ block&let*&return-from\cr catch&load-time-value&setq\cr eval-when&locally&symbol-macrolet\cr flet&macrolet&tagbody\cr function&multiple-value-call&the\cr go&multiple-value-prog1&throw\cr if&progn&unwind-protect\cr labels&progv&\cr let&quote&\cr }

\endsubsubsubsubsection%{Special Forms}

\beginsubsubsubsubsection{Macro Forms}

If the //[[CL:Glossary:operator]]// names a //[[CL:Glossary:macro]]//, its associated //[[CL:Glossary:macro function]]// is applied to the entire //[[CL:Glossary:form]]// and the result of that application is used in place of the original //[[CL:Glossary:form]]//.

Specifically, a //[[CL:Glossary:symbol]]// names a //[[CL:Glossary:macro]]// in a given //[[CL:Glossary:lexical environment]]// if **[[CL:Functions:macro-function]]** is //[[CL:Glossary:true]]// of the  //[[CL:Glossary:symbol]]// and that //[[CL:Glossary:environment]]//. The //[[CL:Glossary:function]]// returned by **[[CL:Functions:macro-function]]** is a //[[CL:Glossary:function]]// of two arguments, called the expansion function. The expansion function is invoked by calling the //[[CL:Glossary:macroexpand hook]]// with
      the expansion function as its first argument,
      the entire //[[CL:Glossary:macro form]]// as its second argument,

    and an //[[CL:Glossary:environment object]]// (corresponding to the current //[[CL:Glossary:lexical environment]]//)
      as its third argument. The //[[CL:Glossary:macroexpand hook]]//, in turn, calls the expansion function with the //[[CL:Glossary:form]]// as its first argument and the //[[CL:Glossary:environment]]// as its second argument. The //[[CL:Glossary:value]]// of the expansion function, which is passed through by the //[[CL:Glossary:macroexpand hook]]//, is a //[[CL:Glossary:form]]//. 

The returned //[[CL:Glossary:form]]// is //[[CL:Glossary:evaluated]]// in place of the original //[[CL:Glossary:form]]//.

\issue{SELF-MODIFYING-CODE:FORBID} The consequences are undefined if a //[[CL:Glossary:macro function]]// destructively modifies any part of its //[[CL:Glossary:form]]// argument.

A //[[CL:Glossary:macro name]]// is not a //[[CL:Glossary:function designator]]//, and cannot be used as the //function// argument to //[[CL:Glossary:functions]]//  such as **[[CL:Functions:apply]]**, **[[CL:Functions:funcall]]**, or **[[CL:Functions:map]]**.

An //[[CL:Glossary:implementation]]// is free to implement a \clisp\ //[[CL:Glossary:special operator]]// as a //[[CL:Glossary:macro]]//.  An //[[CL:Glossary:implementation]]// is free to implement any //[[CL:Glossary:macro]]// //[[CL:Glossary:operator]]// as a //[[CL:Glossary:special operator]]//, but only if an equivalent definition of the //[[CL:Glossary:macro]]// is also provided.

\Thenextfigure\ lists some //[[CL:Glossary:defined names]]// that are applicable to //[[CL:Glossary:macros]]//.

\displaythree{Defined names applicable to macros}{ *macroexpand-hook*&macro-function&macroexpand-1\cr defmacro&macroexpand&macrolet\cr }

\endsubsubsubsubsection%{Macro Forms}

\beginsubsubsubsubsection{Function Forms} \DefineSection{FunctionForms}

If the //[[CL:Glossary:operator]]// is a //[[CL:Glossary:symbol]]// naming a //[[CL:Glossary:function]]//, the //[[CL:Glossary:form]]// represents a //[[CL:Glossary:function form]]//, and the //[[CL:Glossary:cdr]]// of the list contains the //[[CL:Glossary:forms]]//  which when evaluated will supply the arguments passed to the //[[CL:Glossary:function]]//.

When a //[[CL:Glossary:function name]]// is not defined,  an error \oftype{undefined-function} should be signaled at run time; \seesection\SemanticConstraints.

A //[[CL:Glossary:function form]]// is evaluated as follows:

The //[[CL:Glossary:subforms]]// in the //[[CL:Glossary:cdr]]// of the original //[[CL:Glossary:form]]// are evaluated in left-to-right order in the current lexical and  dynamic //[[CL:Glossary:environments]]//.  The //[[CL:Glossary:primary value]]// of each such //[[CL:Glossary:evaluation]]// becomes an //[[CL:Glossary:argument]]// to the named //[[CL:Glossary:function]]//;

any additional //[[CL:Glossary:values]]// returned by the //[[CL:Glossary:subforms]]// are discarded.

The //[[CL:Glossary:functional value]]// of the //[[CL:Glossary:operator]]//  is retrieved from the //[[CL:Glossary:lexical environment]]//, and that //[[CL:Glossary:function]]// is invoked with the indicated arguments.

\issue{FUNCTION-CALL-EVALUATION-ORDER:MORE-UNSPECIFIED} Although the order of //[[CL:Glossary:evaluation]]// of  the //[[CL:Glossary:argument]]// //[[CL:Glossary:subforms]]// themselves is  strictly left-to-right, it is not specified whether  the definition of the //[[CL:Glossary:operator]]// in a //[[CL:Glossary:function form]]// is looked up  before the //[[CL:Glossary:evaluation]]// of the //[[CL:Glossary:argument]]// //[[CL:Glossary:subforms]]//, after the //[[CL:Glossary:evaluation]]// of the //[[CL:Glossary:argument]]// //[[CL:Glossary:subforms]]//, or between the //[[CL:Glossary:evaluation]]// of any two //[[CL:Glossary:argument]]// //[[CL:Glossary:subforms]]//  if there is more than one such //[[CL:Glossary:argument]]// //[[CL:Glossary:subform]]//.   For example, the following might return 23 or~24.

\code
 (defun foo (x) (+ x 3))
 (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
 (foo (progn (bar) 20)) \endcode

A //[[CL:Glossary:binding]]// for a //[[CL:Glossary:function name]]// can be //[[CL:Glossary:established]]// in  one of several ways.  A //[[CL:Glossary:binding]]// for a //[[CL:Glossary:function name]]// in  the //[[CL:Glossary:global environment]]// can be //[[CL:Glossary:established]]// by 
 \macref{defun},
 \SETFof{fdefinition},

 \SETFof{symbol-function},

 **[[CL:Functions:ensure-generic-function]]**,
 \macref{defmethod} (implicitly, due to **[[CL:Functions:ensure-generic-function]]**), or
 \macref{defgeneric}. A //[[CL:Glossary:binding]]// for a //[[CL:Glossary:function name]]// in the //[[CL:Glossary:lexical environment]]// can be //[[CL:Glossary:established]]// by
   \specref{flet} or \specref{labels}. \issue{WITH-ADDED-METHODS:DELETE}

\issue{GENERIC-FLET-POORLY-DESIGNED:DELETE}

\Thenextfigure\ lists some //[[CL:Glossary:defined names]]// that are applicable to //[[CL:Glossary:functions]]//.

\issue{GENERIC-FLET-POORLY-DESIGNED:DELETE} \issue{WITH-ADDED-METHODS:DELETE} \displaythree{Some function-related defined names}{ apply&fdefinition&mapcan\cr call-arguments-limit&flet&mapcar\cr complement&fmakunbound&mapcon\cr constantly&funcall&mapl\cr defgeneric&function&maplist\cr defmethod&functionp&multiple-value-call\cr defun&labels&reduce\cr fboundp&map&symbol-function\cr }

\endsubsubsubsubsection%{Function Forms}

\beginsubsubsubsubsection{Lambda Forms} \DefineSection{LambdaForms}

A //[[CL:Glossary:lambda form]]// is similar to a //[[CL:Glossary:function form]]//, except that the //[[CL:Glossary:function name]]// is replaced by a //[[CL:Glossary:lambda expression]]//.

A //[[CL:Glossary:lambda form]]// is equivalent to using //[[CL:Glossary:funcall]]// of a //[[CL:Glossary:lexical closure]]// of the //[[CL:Glossary:lambda expression]]// on the given //[[CL:Glossary:arguments]]//. (In practice, some compilers are more likely to produce inline code  for a //[[CL:Glossary:lambda form]]// than for an arbitrary named function  that has been declared **[[CL:Declarations:inline]]**; however, such a difference is not semantic.)

For further information, \seesection\LambdaExpressions.

\endsubsubsubsubsection%{Lambda Forms}

\endsubsubsubsection%{Conses as forms}

\beginsubsubsubsection{Self-Evaluating Objects}

\issue{EVAL-OTHER:SELF-EVALUATE} A //[[CL:Glossary:form]]// that is neither a //[[CL:Glossary:symbol]]// nor a //[[CL:Glossary:cons]]// is  defined to be a //[[CL:Glossary:self-evaluating object]]//.  //[[CL:Glossary:Evaluating]]// such an //[[CL:Glossary:object]]// //[[CL:Glossary:yields]]// the //[[CL:Glossary:same]]// //[[CL:Glossary:object]]//  as a result.

Certain specific //[[CL:Glossary:symbols]]// and //[[CL:Glossary:conses]]// might also happen  to be ``self-evaluating'' but only as a special case of a more  general set of rules for the //[[CL:Glossary:evaluation]]// of //[[CL:Glossary:symbols]]// and //[[CL:Glossary:conses]]//; such //[[CL:Glossary:objects]]// are not considered to be //[[CL:Glossary:self-evaluating objects]]//.

The consequences are undefined if //[[CL:Glossary:literal objects]]// (including //[[CL:Glossary:self-evaluating objects]]//) are destructively modified.

\beginsubsubsubsubsection{Examples of Self-Evaluating Objects}

//[[CL:Glossary:Numbers]]//, //[[CL:Glossary:pathnames]]//, and //[[CL:Glossary:arrays]]// are examples of //[[CL:Glossary:self-evaluating objects]]//.

\code
 3 \EV 3
 #c(2/3 5/8) \EV #C(2/3 5/8)
 #p"S:[BILL]OTHELLO.TXT" \EV #P"S:[BILL]OTHELLO.TXT"
 #(a b c) \EV #(A B C)
 "fred smith" \EV "fred smith" \endcode

\endsubsubsubsubsection%{Examples of Self-Evaluating Objects}

\endsubsubsubsection%{Self-Evaluating Objects}

\endsubsubsection%{Form Evaluation}

\endSubsection%{The Evaluation Model}

\beginsubsection{Lambda Expressions} \DefineSection{LambdaExpressions}

In a //[[CL:Glossary:lambda expression]]//, the body is evaluated in a lexical //[[CL:Glossary:environment]]// that is formed by adding the //[[CL:Glossary:binding]]// of  each //[[CL:Glossary:parameter]]// in the //[[CL:Glossary:lambda list]]// with the corresponding //[[CL:Glossary:value]]// from the //[[CL:Glossary:arguments]]// to the current lexical //[[CL:Glossary:environment]]//.

For further discussion of how //[[CL:Glossary:bindings]]// are //[[CL:Glossary:established]]//  based on the //[[CL:Glossary:lambda list]]//, \seesection\LambdaLists.

The body of a //[[CL:Glossary:lambda expression]]// is an //[[CL:Glossary:implicit progn]]//; the //[[CL:Glossary:values]]// it returns are returned by the //[[CL:Glossary:lambda expression]]//.

\endsubsection%{Lambda Expressions}

\beginSubsection{Closures and Lexical Binding}
 

A //[[CL:Glossary:lexical closure]]// is a //[[CL:Glossary:function]]// that can refer to and alter the values of //[[CL:Glossary:lexical bindings]]// //[[CL:Glossary:established]]// by //[[CL:Glossary:binding]]// //[[CL:Glossary:forms]]// that textually include the function definition.
  Consider this code, where \f{x} is not declared **[[CL:Declarations:special]]**:
  \code
 (defun two-funs (x)
   (list (function (lambda () x))
         (function (lambda (y) (setq x y)))))
 (setq funs (two-funs 6))
 (funcall (car funs)) \EV 6
 (funcall (cadr funs) 43) \EV 43
 (funcall (car funs)) \EV 43 \endcode

\Thespecform{function} coerces a  //[[CL:Glossary:lambda expression]]// into a //[[CL:Glossary:closure]]// in which the  //[[CL:Glossary:lexical environment]]// in effect when the //[[CL:Glossary:special form]]// is evaluated is captured along with the //[[CL:Glossary:lambda expression]]//.

The function \f{two-funs} returns a //[[CL:Glossary:list]]// of two  //[[CL:Glossary:functions]]//, each of which refers to the //[[CL:Glossary:binding]]// of the variable \f{x} created on entry to the function \f{two-funs} when it was called.

This variable has the value \f{6} initially, but \specref{setq} can alter this //[[CL:Glossary:binding]]//.

The //[[CL:Glossary:lexical closure]]// created for the first  //[[CL:Glossary:lambda expression]]// does not ``snapshot'' the //[[CL:Glossary:value]]// \f{6} for \f{x} when the //[[CL:Glossary:closure]]// is created; rather it captures the //[[CL:Glossary:binding]]// of \f{x}. The second //[[CL:Glossary:function]]// can be used to alter the //[[CL:Glossary:value]]// in the same (captured) //[[CL:Glossary:binding]]// (to \f{43}, in the example), and this altered variable binding then affects the value returned by the first //[[CL:Glossary:function]]//.

                     

In situations where a //[[CL:Glossary:closure]]// of a  //[[CL:Glossary:lambda expression]]// over the same set of //[[CL:Glossary:bindings]]// may be produced more than once, the various resulting //[[CL:Glossary:closures]]// may or may not be //[[CL:Glossary:identical]]//, at the discretion of the //[[CL:Glossary:implementation]]//. That is, two //[[CL:Glossary:functions]]// that are behaviorally indistinguishable might or might not be //[[CL:Glossary:identical]]//. Two //[[CL:Glossary:functions]]// that are behaviorally distinguishable are //[[CL:Glossary:distinct]]//. For example:
  \code
 (let ((x 5) (funs '()))
   (dotimes (j 10)                          
     (push #'(lambda (z)                        
               (if (null z) (setq x 0) (+ x z)))
           funs))
   funs) \endcode The result of the above //[[CL:Glossary:form]]// is a //[[CL:Glossary:list]]// of ten //[[CL:Glossary:closures]]//. Each requires only the //[[CL:Glossary:binding]]// of \f{x}. It is the same //[[CL:Glossary:binding]]// in each case,  but the ten //[[CL:Glossary:closure]]// //[[CL:Glossary:objects]]// might or might not be //[[CL:Glossary:identical]]//. On the other hand, the result of the //[[CL:Glossary:form]]//
  \code
 (let ((funs '()))     
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z)
                        (if (null z) (setq x 0) (+ x z))))
             funs)))
  funs) \endcode is also a //[[CL:Glossary:list]]// of ten //[[CL:Glossary:closures]]//. However, in this case no two of the //[[CL:Glossary:closure]]// //[[CL:Glossary:objects]]// can be //[[CL:Glossary:identical]]// because each //[[CL:Glossary:closure]]// is closed over a distinct //[[CL:Glossary:binding]]// of \f{x}, and these //[[CL:Glossary:bindings]]// can be behaviorally distinguished because of the use of \specref{setq}.
 

The result of the //[[CL:Glossary:form]]//
  \code
 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z) (+ x z)))
            funs)))
   funs) \endcode is a //[[CL:Glossary:list]]// of ten //[[CL:Glossary:closure]]// //[[CL:Glossary:objects]]// that might or might not be //[[CL:Glossary:identical]]//. A different //[[CL:Glossary:binding]]// of \f{x} is involved for each //[[CL:Glossary:closure]]//, but the //[[CL:Glossary:bindings]]// cannot be distinguished because their values are the //[[CL:Glossary:same]]// and immutable (there being no occurrence of \specref{setq} on \f{x}).  A compiler could internally transform the //[[CL:Glossary:form]]// to
  \code
 (let ((funs '()))
   (dotimes (j 10)
     (push (function (lambda (z) (+ 5 z)))
           funs))
  funs) \endcode where the //[[CL:Glossary:closures]]// may be //[[CL:Glossary:identical]]//.

 

It is possible that a //[[CL:Glossary:closure]]// does not close over any variable bindings. In the code fragment
  \code
 (mapcar (function (lambda (x) (+ x 2))) y) \endcode the function \f{(lambda (x) (+ x 2))} contains no references to any outside object. In this case, the same //[[CL:Glossary:closure]]// might be returned for all evaluations of the \specref{function} //[[CL:Glossary:form]]//.

\endSubsection%{Closures and Lexical Binding}
  \beginSubsection{Shadowing} \DefineSection{Shadowing}

If two //[[CL:Glossary:forms]]// that //[[CL:Glossary:establish]]// //[[CL:Glossary:lexical bindings]]// with the same //[[CL:Glossary:name]]// $N$ are textually nested, then references to $N$ within the inner //[[CL:Glossary:form]]// refer to the //[[CL:Glossary:binding]]// established by the inner //[[CL:Glossary:form]]//; the inner //[[CL:Glossary:binding]]// for $N$ \newtermidx{shadows}{shadow} the outer //[[CL:Glossary:binding]]// for $N$.  Outside the inner //[[CL:Glossary:form]]// but inside the outer one, references to $N$ refer to the //[[CL:Glossary:binding]]// established by the outer //[[CL:Glossary:form]]//.  For example:

\code
 (defun test (x z)
   (let ((z (* x 2)))
     (print z))
   z) \endcode The //[[CL:Glossary:binding]]// of the variable \f{z} by \specref{let} shadows the //[[CL:Glossary:parameter]]// binding for the function \f{test}.  The reference to the variable \f{z} in the **[[CL:Functions:print]]** //[[CL:Glossary:form]]// refers to the \specref{let} binding. The reference to \f{z} at the end of the function \f{test}  refers to the //[[CL:Glossary:parameter]]// named \f{z}.

Constructs that are lexically scoped act as if new names were generated for each //[[CL:Glossary:object]]// on each execution.  Therefore, dynamic shadowing cannot occur.  For example:

\code
 (defun contorted-example (f g x)
   (if (= x 0)
       (funcall f)
       (block here
          (+ 5 (contorted-example g
                                  #'(lambda () (return-from here 4))
                                  (- x 1)))))) \endcode Consider the call \f{(contorted-example nil nil 2)}.  This produces \f{4}.  During the course of execution, there are three calls to \f{contorted-example}, interleaved with two  blocks:

\code
 (contorted-example nil nil 2)
   (block here\ssso ...)
     (contorted-example nil #'(lambda () (return-from here\ssso 4)) 1)
       (block here\ssst ...)
         (contorted-example #'(lambda () (return-from here\ssso 4))
                            #'(lambda () (return-from here\ssst 4))
                            0)
             (funcall f)
                    where f \EV #'(lambda () (return-from here\ssso 4))
                 (return-from here\ssso 4) \endcode At the time the \f{funcall} is executed there are two \specref{block} //[[CL:Glossary:exit points]]// outstanding, each apparently named \f{here}. The \specref{return-from} //[[CL:Glossary:form]]// executed as a result of the \f{funcall} operation refers to the outer outstanding //[[CL:Glossary:exit point]]// (here\ssso), not the inner one (here\ssst). It refers to that //[[CL:Glossary:exit point]]// textually visible at the point of execution of \specref{function} (here abbreviated by the \f{\#'} syntax) that resulted in creation of the //[[CL:Glossary:function]]// //[[CL:Glossary:object]]// actually invoked by  **[[CL:Functions:funcall]]**.                       

If, in this example, one were to change the \f{(funcall f)} to \f{(funcall g)}, then the value of the call \f{(contorted-example nil nil 2)} would be \f{9}.  The value would change because  **[[CL:Functions:funcall]]** would cause the execution of \f{(return-from here\ssst\ 4)}, thereby causing a return from the inner //[[CL:Glossary:exit point]]// (here\ssst). When that occurs, the value \f{4} is returned from the middle invocation of \f{contorted-example}, \f{5} is added to that to get \f{9}, and that value is returned from the outer block and the outermost call to \f{contorted-example}.  The point is that the choice of //[[CL:Glossary:exit point]]// returned from has nothing to do with its being innermost or outermost; rather, it depends on the lexical environment that is packaged up with a //[[CL:Glossary:lambda expression]]// when \specref{function} is executed.
                                   \endSubsection%{Shadowing}

\beginSubsection{Extent}

\f{Contorted-example} works only because the //[[CL:Glossary:function]]// named by \f{f} is invoked during the //[[CL:Glossary:extent]]// of the  //[[CL:Glossary:exit point]]//. Once the flow of execution has left the block, the //[[CL:Glossary:exit point]]// is //[[CL:Glossary:disestablished]]//.  For example:

\code
 (defun invalid-example ()
   (let ((y (block here #'(lambda (z) (return-from here z)))))
     (if (numberp y) y (funcall y 5)))) \endcode One might expect the call \f{(invalid-example)} to produce \f{5} by the following incorrect reasoning: \specref{let} binds \f{y} to the value of \specref{block}; this value is a //[[CL:Glossary:function]]// resulting from the //[[CL:Glossary:lambda expression]]//.  Because \f{y} is not a number, it is invoked on the value \f{5}.  The \specref{return-from} should then return this value from the                       //[[CL:Glossary:exit point]]// named \f{here}, thereby exiting from the block again and giving \f{y} the value \f{5} which, being a number, is then returned as the value of the call to \f{invalid-example}.

The argument fails only because //[[CL:Glossary:exit points]]// have  //[[CL:Glossary:dynamic extent]]//.  The argument is correct up to the execution of \specref{return-from}.  The execution of \specref{return-from} should signal an error \oftype{control-error}, however, not because it cannot refer to the //[[CL:Glossary:exit point]]//, but because it does correctly refer to an //[[CL:Glossary:exit point]]// and that  //[[CL:Glossary:exit point]]// has been //[[CL:Glossary:disestablished]]//.

A reference by name to a dynamic //[[CL:Glossary:exit point]]// binding such as a //[[CL:Glossary:catch tag]]// refers to the most recently  //[[CL:Glossary:established]]// //[[CL:Glossary:binding]]// of that name that has not been  //[[CL:Glossary:disestablished]]//.  For example:

\code
 (defun fun1 (x)
   (catch 'trap (+ 3 (fun2 x))))
 (defun fun2 (y)
   (catch 'trap (* 5 (fun3 y))))
 (defun fun3 (z)
   (throw 'trap z)) \endcode Consider the call \f{(fun1 7)}.  The result is \f{10}.  At the time the \specref{throw} is executed, there are two outstanding catchers with the name \f{trap}: one established within procedure \f{fun1}, and the other within procedure \f{fun2}.  The latter is the more recent, and so the value \f{7} is returned from \specref{catch} in \f{fun2}. Viewed from within \f{fun3}, the \specref{catch}  in \f{fun2} shadows the one in \f{fun1}. Had \f{fun2} been defined as

\code
 (defun fun2 (y)
   (catch 'snare (* 5 (fun3 y)))) \endcode then the two //[[CL:Glossary:exit points]]//  would have different //[[CL:Glossary:names]]//, and therefore the one in \f{fun1} would not be shadowed.  The result would then have been \f{7}.

\endSubsection%{Extent}

\beginSubsection{Return Values}

Ordinarily the result of calling a //[[CL:Glossary:function]]// is a single //[[CL:Glossary:object]]//. Sometimes, however, it is convenient for a function to compute several //[[CL:Glossary:objects]]// and return them.

In order to receive other than exactly one value from a //[[CL:Glossary:form]]//, one of several //[[CL:Glossary:special forms]]// or //[[CL:Glossary:macros]]// must be used to request those values.  If a //[[CL:Glossary:form]]// produces //[[CL:Glossary:multiple values]]// which were not requested in this way, then the first value is given to the caller and all others are discarded; if the //[[CL:Glossary:form]]// produces zero values, then the caller receives \nil\ as a value.

\Thenextfigure\ lists  some //[[CL:Glossary:operators]]// for receiving //[[CL:Glossary:multiple values]]//\meaning{2}. These //[[CL:Glossary:operators]]// can be used to specify 
    one or more //[[CL:Glossary:forms]]// to //[[CL:Glossary:evaluate]]//  and where to put the //[[CL:Glossary:values]]// returned by those //[[CL:Glossary:forms]]//.

\displaythree{Some operators applicable to receiving multiple values}{ multiple-value-bind&multiple-value-prog1&return-from\cr multiple-value-call&multiple-value-setq&throw\cr multiple-value-list&return&\cr }

\Thefunction{values} can produce //[[CL:Glossary:multiple values]]//\meaning{2}. \f{(values)} returns zero values; \f{(values //form//)} returns the //[[CL:Glossary:primary value]]// returned by //form//; \f{(values //form1// //form2//)} returns two values,
    the //[[CL:Glossary:primary value]]// of //form1// and the //[[CL:Glossary:primary value]]// of //form2//; and so on.

See \conref{multiple-values-limit} and **[[CL:Functions:values-list]]**.

\endSubsection%{Return Values}

