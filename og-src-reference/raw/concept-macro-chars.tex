

If the reader encounters a //[[CL:Glossary:macro character]]//, then its associated //[[CL:Glossary:reader macro function]]//  is invoked and may produce an //[[CL:Glossary:object]]// to be returned. This //[[CL:Glossary:function]]// may read the //[[CL:Glossary:characters]]//  following the //[[CL:Glossary:macro character]]// in the //[[CL:Glossary:stream]]//  in any syntax and return the //[[CL:Glossary:object]]// represented by that syntax.

Any //[[CL:Glossary:character]]// can be made to be a //[[CL:Glossary:macro character]]//. The //[[CL:Glossary:macro characters]]// defined initially in a //[[CL:Glossary:conforming implementation]]// include the following:

\beginsubsection{Left-Parenthesis} \DefineSection{LeftParen}\idxcode{(}\idxtext{Left-Parenthesis (reader macro)}\idxref{list}

The //[[CL:Glossary:left-parenthesis]]// initiates reading of a //[[CL:Glossary:list]]//. **[[CL:Functions:read]]** is called recursively to read successive //[[CL:Glossary:objects]]// until a right parenthesis is found in the input //[[CL:Glossary:stream]]//. A //[[CL:Glossary:list]]// of the //[[CL:Glossary:objects]]// read is returned.  Thus

\code
 (a b c) \endcode is read as a //[[CL:Glossary:list]]// of three //[[CL:Glossary:objects]]// (the //[[CL:Glossary:symbols]]// \f{a}, \f{b}, and \f{c}). The right parenthesis need not immediately follow the printed representation of the last //[[CL:Glossary:object]]//; //[[CL:Glossary:whitespace]]//\meaning{2}                               characters and comments may precede it.

If no //[[CL:Glossary:objects]]// precede the right parenthesis,  it reads as a //[[CL:Glossary:list]]// of zero //[[CL:Glossary:objects]]//  (the //[[CL:Glossary:empty list]]//).

If a //[[CL:Glossary:token]]// that is just a dot\idxterm{dot}\idxcode{.} not immediately preceded by an escape character is read after some //[[CL:Glossary:object]]// then exactly one more //[[CL:Glossary:object]]// must follow the dot, possibly preceded or followed by //[[CL:Glossary:whitespace]]//\meaning{2} or a comment, followed by the right parenthesis:

\code
 (a b c . d) \endcode This means that the //[[CL:Glossary:cdr]]// of the last //[[CL:Glossary:cons]]// in the  //[[CL:Glossary:list]]// is not \nil, but rather the //[[CL:Glossary:object]]// whose representation followed the dot. The above example might have been the result of evaluating

\code
 (cons 'a (cons 'b (cons 'c 'd))) \endcode Similarly,

\code
 (cons 'this-one 'that-one) \EV (this-one . that-one) \endcode It is permissible for the //[[CL:Glossary:object]]//  following the dot to be a //[[CL:Glossary:list]]//:

\code
 (a b c d . (e f . (g))) \EQ (a b c d e f g) \endcode

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:lists]]// and //[[CL:Glossary:conses]]//, \seesection\PrintingListsAndConses.

\endsubsection%{Left-Parenthesis}

\beginsubsection{Right-Parenthesis} \idxcode{)}\idxtext{Right-Parenthesis (reader macro)}

The //[[CL:Glossary:right-parenthesis]]// is invalid  except when used in conjunction with the left parenthesis character. For more information, \seesection\ReaderAlgorithm.

\endsubsection%{Right-Parenthesis}

\beginsubsection{Single-Quote} \DefineSection{QuoteMacro} \idxcode{'}\idxtext{Single-Quote (reader macro)}\idxtext{quotation (of forms)}\idxref{quote}

\b{Syntax:}  \f{'\metaparam{exp}}

A //[[CL:Glossary:single-quote]]// introduces an //[[CL:Glossary:expression]]// to be ``quoted.'' //[[CL:Glossary:Single-quote]]// followed by an //[[CL:Glossary:expression]]// //exp//  is treated by the //[[CL:Glossary:Lisp reader]]// as an abbreviation for and is parsed identically to the //[[CL:Glossary:expression]]// \f{(quote //exp//)}. \Seespec{quote}.

\beginsubsubsection{Examples of Single-Quote}

\code
 'foo \EV FOO
 ''foo \EV (QUOTE FOO)
 (car ''foo) \EV QUOTE \endcode

\endsubsubsection%{Examples of Single-Quote}

\endsubsection%{Single-Quote}

\beginsubsection{Semicolon} \idxcode{;}\idxtext{Semicolon (reader macro)}\idxtext{comment}

\b{Syntax:} \f{;\metaparam{text}}

A //[[CL:Glossary:semicolon]]// introduces //[[CL:Glossary:characters]]// that are to be ignored, such as comments.  The //[[CL:Glossary:semicolon]]// and all //[[CL:Glossary:characters]]// up to and including the next //[[CL:Glossary:newline]]// or end of file are ignored.

\beginsubsubsection{Examples of Semicolon}

\code
 (+ 3 ; three
    4) \EV 7     \endcode

\endsubsubsection%{Examples of Semicolon}

\beginsubsubsection{Notes about Style for Semicolon}

Some text editors make assumptions about desired indentation based on the number of //[[CL:Glossary:semicolons]]// that begin a comment.  The following style  conventions are common, although not by any means universal.  

\beginsubsubsubsection{Use of Single Semicolon}

Comments that begin with a single //[[CL:Glossary:semicolon]]// are all aligned to  the same column at the right (sometimes called the ``comment column''). The text of such a comment generally applies only to the line on which it appears. Occasionally two or three contain a single sentence together; this is sometimes indicated by indenting all but the first with an additional space (after the //[[CL:Glossary:semicolon]]//).

\endsubsubsubsection%{Use of Single Semicolon}

\beginsubsubsubsection{Use of Double Semicolon}

Comments that begin with a double //[[CL:Glossary:semicolon]]// are all aligned to the same level of indentation as a //[[CL:Glossary:form]]// would be at that same position in the //[[CL:Glossary:code]]//.

The text of such a comment usually describes
    the state of the //[[CL:Glossary:program]]// at the point where the comment occurs,
    the //[[CL:Glossary:code]]// which follows the comment,
 or both.

\endsubsubsubsection%{Use of Double Semicolon}

\beginsubsubsubsection{Use of Triple Semicolon}

Comments that begin with a triple //[[CL:Glossary:semicolon]]// are all aligned to the left margin.  Usually they are used prior to a definition or set of definitions, rather than within a definition.

\endsubsubsubsection%{Use of Triple Semicolon}

\beginsubsubsubsection{Use of Quadruple Semicolon}

Comments that begin with a quadruple //[[CL:Glossary:semicolon]]// are all aligned to the left margin, and generally contain only a short piece of text that serve as a title for the code which follows, and might be used in the header or footer of a program that prepares code for presentation as  a hardcopy document.

\endsubsubsubsection%{Use of Quadruple Semicolon}

\beginsubsubsubsection{Examples of Style for Semicolon}

\code ;;;; Math Utilities

;;; FIB computes the the Fibonacci function in the traditional ;;; recursive way.

(defun fib (n)
  (check-type n integer)
  ;; At this point we're sure we have an integer argument.
  ;; Now we can get down to some serious computation.
  (cond ((< n 0)
         ;; Hey, this is just supposed to be a simple example.
         ;; Did you really expect me to handle the general case?
         (error "FIB got ~D as an argument." n))
        ((< n 2) n)             ;fib[0]=0 and fib[1]=1
        ;; The cheap cases didn't work.
        ;; Nothing more to do but recurse.
        (t (+ (fib (- n 1))     ;The traditional formula
              (fib (- n 2)))))) ; is fib[n-1]+fib[n-2]. \endcode

\endsubsubsubsection%{Examples of Style for Semicolon}

\endsubsubsection%{Notes about Style for Semicolon}

\endsubsection%{Semicolon}

\beginsubsection{Double-Quote} \DefineSection{Doublequote} \idxtext{Double-Quote (reader macro)}\idxtext{quotation (of strings)}\idxref{string}

\b{Syntax:} \f{"\metaparam{text}"}

The //[[CL:Glossary:double-quote]]// is used to begin and end a //[[CL:Glossary:string]]//. When a //[[CL:Glossary:double-quote]]// is encountered, //[[CL:Glossary:characters]]// are read from the //[[CL:Glossary:input]]// //[[CL:Glossary:stream]]//  and accumulated until another //[[CL:Glossary:double-quote]]// is encountered. If a //[[CL:Glossary:single escape]]// //[[CL:Glossary:character]]// is seen, the //[[CL:Glossary:single escape]]// //[[CL:Glossary:character]]// is discarded, the next //[[CL:Glossary:character]]// is accumulated, and accumulation continues.

The accumulated //[[CL:Glossary:characters]]//  up to but not including the matching //[[CL:Glossary:double-quote]]//  are made into a //[[CL:Glossary:simple string]]// and returned. \issue{CHARACTER-PROPOSAL:2-1-1} It is //[[CL:Glossary:implementation-dependent]]// which //[[CL:Glossary:attributes]]// of the accumulated characters are removed in this process.

Examples of the use of the //[[CL:Glossary:double-quote]]// character are in \thenextfigure. 

\showtwo{Examples of the use of double-quote}{ \f{"Foo"}                          & ;A string with three characters in it \cr \f{""}			           & ;An empty string \cr \f{"\\"APL\\\\360?\\" he cried."}  & ;A string with twenty characters \cr \f{"|x| = |-x|"}                   & ;A ten-character string \cr }

Note that to place a single escape character or a //[[CL:Glossary:double-quote]]// into a string, such a character must be preceded by a single escape character. Note, too, that a multiple escape character need not be quoted by a  single escape character within a string.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:strings]]//, \seesection\PrintingStrings.

\endsubsection%{Double-Quote}

\beginsubsection{Backquote} \DefineSection{Backquote} \idxcode{`}\idxtext{Backquote (reader macro)}\idxtext{quotation (of forms)} \idxref{quote}\idxref{list}\idxref{cons}

The //[[CL:Glossary:backquote]]// introduces a template of a data structure to be built.   For example, writing

\code
 `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y)) \endcode is roughly equivalent to writing

\code
 (list 'cond 
       (cons (list 'numberp x) y) 
       (list* 't (list 'print x) y)) \endcode Where a comma occurs in the template,  the //[[CL:Glossary:expression]]// following the comma is to be evaluated to produce an //[[CL:Glossary:object]]// to be inserted at that point.  Assume \f{b} has the value 3, for example, then evaluating the //[[CL:Glossary:form]]// denoted by \f{`(a b ,b ,(+ b 1) b)} produces the result \f{(a b 3 4 b)}.

If a comma is immediately followed by an //[[CL:Glossary:at-sign]]//,  then the //[[CL:Glossary:form]]// following the //[[CL:Glossary:at-sign]]// is evaluated to produce a //[[CL:Glossary:list]]// of //[[CL:Glossary:objects]]//. These //[[CL:Glossary:objects]]// are then ``spliced'' into place in the template.  For example, if \f{x} has the value \f{(a b c)}, then

\code
 `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x)) \EV (x (a b c) a b c foo b bar (b c) baz b c) \endcode

The backquote syntax can be summarized formally as follows.

\beginlist \itemitem{\bull} \f{`//basic//} is the same as \f{'//basic//}, that is, \f{(quote //basic//)}, for any //[[CL:Glossary:expression]]//  //basic// that is not a //[[CL:Glossary:list]]// or a general //[[CL:Glossary:vector]]//.

\itemitem{\bull} \f{`,//form//} is the same as //form//, for any //form//, provided that the representation of //form// does not begin with //[[CL:Glossary:at-sign]]// or //[[CL:Glossary:dot]]//.  (A similar caveat holds for all occurrences of a form after a //[[CL:Glossary:comma]]//.)

\itemitem{\bull} \f{`,@//form//} has undefined consequences.

\itemitem{\bull} \f{`(x1 x2 x3 ... xn . atom)} may be interpreted to mean

\code
 (append \lbracket\ x1\rbracket \lbracket\ x2\rbracket \lbracket\ x3\rbracket ... \lbracket\ xn\rbracket (quote atom)) \endcode where the brackets are used to indicate a transformation of an //xj// as follows:

\beginlist \itemitem{--} \f{[//form//]} is interpreted as \f{(list `//form//)},  which contains a backquoted form that must then be further interpreted.

\itemitem{--} \f{[,//form//]} is interpreted as \f{(list //form//)}.

\itemitem{--} \f{[,@//form//]} is interpreted as //form//. \endlist

\itemitem{\bull} \f{`(x1 x2 x3 ... xn)} may be interpreted to mean the same as the backquoted form \f{`(x1 x2 x3 ... xn . \nil)}, thereby reducing it to the previous case.

\itemitem{\bull} \f{`(x1 x2 x3 ... xn . ,form)} may be interpreted to mean

\code
 (append \lbracket\ x1\rbracket \lbracket\ x2\rbracket \lbracket\ x3\rbracket ... \lbracket\ xn\rbracket form) \endcode where the brackets indicate a transformation of an {\tt xj} as described above.

\itemitem{\bull} \f{`(x1 x2 x3 ... xn . ,@form)} has undefined consequences.

\itemitem{\bull} \f{`\#(x1 x2 x3 ... xn)} may be interpreted to mean \f{(apply \#'vector `(x1 x2 x3 ... xn))}. \endlist

Anywhere ``\f{,@}'' may be used, the syntax ``\f{,.}'' may be used instead to indicate that it is permissible to operate //[[CL:Glossary:destructively]]// on  the //[[CL:Glossary:list structure]]//  produced by the form following the ``\f{,.}''  (in effect, to use **[[CL:Functions:nconc]]** instead of **[[CL:Functions:append]]**).

If the backquote syntax is nested, the innermost backquoted form should be expanded first.  This means that if several commas occur in a row, the leftmost one belongs to the innermost //[[CL:Glossary:backquote]]//.

An //[[CL:Glossary:implementation]]// is free to interpret a backquoted //[[CL:Glossary:form]]// $F\sub 1$ as any //[[CL:Glossary:form]]// $F\sub 2$ that, when evaluated, will produce a result that is the //[[CL:Glossary:same]]// under **[[CL:Functions:equal]]** as the result implied by the above definition,  provided that the side-effect behavior of the substitute //[[CL:Glossary:form]]// $F\sub 2$  is also consistent with the description given above.

The constructed copy of the template might or might not share //[[CL:Glossary:list]]// structure with the template itself.  As an example, the above definition implies that

\code
 `((,a b) ,c ,@d) \endcode will be interpreted as if it were

\code
 (append (list (append (list a) (list 'b) '\nil)) (list c) d '\nil) \endcode but it could also be legitimately interpreted to mean any of the following:

\code
 (append (list (append (list a) (list 'b))) (list c) d)
 (append (list (append (list a) '(b))) (list c) d)
 (list* (cons a '(b)) c d)
 (list* (cons a (list 'b)) c d)
 (append (list (cons a '(b))) (list c) d)
 (list* (cons a '(b)) c (copy-list d)) \endcode
                \beginsubsubsection{Notes about Backquote}

Since the exact manner in which the //[[CL:Glossary:Lisp reader]]// will parse an //[[CL:Glossary:expression]]// involving the //[[CL:Glossary:backquote]]// //[[CL:Glossary:reader macro]]//  is not specified, an //[[CL:Glossary:implementation]]// is free to choose any representation that preserves the semantics described.

Often an //[[CL:Glossary:implementation]]// will choose a representation that facilitates pretty printing of the expression, so that \f{(pprint `(a ,b))} will display \f{`(a ,b)} and not, for example, \f{(list 'a b)}.  However, this is not a requirement.

Implementors who have no particular reason to make one choice or another might wish to refer to {\IEEEScheme}, which identifies a popular choice of representation for such expressions that might provide useful to be useful compatibility for some user communities.  There is no requirement, however, that any //[[CL:Glossary:conforming implementation]]// use this particular representation. This information is provided merely for cross-reference purposes.

\endsubsubsection%{Notes about Backquote}

\endsubsection%{Backquote}

\beginsubsection{Comma} \idxcode{,}\idxtext{Comma (reader macro)}\idxtext{quotation (of forms)} \idxref{quote}\idxref{list}\idxref{cons}

            The //[[CL:Glossary:comma]]// is part of the backquote syntax; \seesection\Backquote. //[[CL:Glossary:Comma]]// is invalid if used other than inside the body of a  backquote //[[CL:Glossary:expression]]// as described above.

\endsubsection%{Comma}

\beginsubsection{Sharpsign} \idxcode{\#}\idxtext{Sharpsign (reader macro)}

//[[CL:Glossary:Sharpsign]]// is a //[[CL:Glossary:non-terminating]]// //[[CL:Glossary:dispatching macro character]]//. It reads an optional 

sequence of digits and then one more character, and uses that character to select a //[[CL:Glossary:function]]// to run as a //[[CL:Glossary:reader macro function]]//.

The //[[CL:Glossary:standard syntax]]// includes constructs introduced by the \f{\#} character. The syntax of these constructs is as follows: a character that identifies the type of construct is  followed by arguments in some form. If the character is a letter, its //[[CL:Glossary:case]]// is not important; \f{\#O} and \f{\#o} are considered to be equivalent, for example.

Certain \f{\#} constructs allow an unsigned decimal number to appear between the \f{\#} and the character.

The //[[CL:Glossary:reader macros]]// associated with the //[[CL:Glossary:dispatching macro character]]// \f{\#} are described later in this section and summarized in \thenextfigure.

{\def\u{undefined} \def\s{signals error} \def\ia{infix argument} \tablefigfour{Standard \# Dispatching Macro Character Syntax}{dispatch char}{purpose}{dispatch char}{purpose}{ Backspace&\s&\f{\{}&\u*\cr Tab&\s&\f{\}}&\u*\cr Newline&\s&+&read-time conditional\cr Linefeed&\s&-&read-time conditional\cr Page&\s&.&read-time evaluation\cr Return&\s&/&\u\cr Space&\s&A, a&array\cr !&\u*&B, b&binary rational\cr \f{"}&\u&C, c&complex number\cr \#&reference to = label&D, d&\u\cr \$&\u&E, e&\u\cr \%&\u&F, f&\u\cr       \&&\u&G, g&\u\cr '&function abbreviation&H, h&\u\cr (&simple vector&I, i&\u\cr )&\s&J, j&\u\cr {\tt *}&bit vector&K, k&\u\cr ,&\u&L, l&\u\cr :&uninterned symbol&M, m&\u\cr ;&\u&N, n&\u\cr \f{<}&\s&O, o&octal rational\cr \f{=}&labels following object&P, p&pathname\cr \f{>}&\u&Q, q&\u\cr ?&\u*&R, r&radix-$n$ rational\cr @&\u&S, s&structure\cr [&\u*&T, t&\u\cr \f{\\}&character object&U, u&\u\cr ]&\u*&V, v&\u\cr {\hat}&\u&W, w&\u\cr \f{\_}&\u&X, x&hexadecimal rational\cr `&\u&Y, y&\u\cr \f{|}&balanced comment&Z, z&\u\cr \f{~}&\u&Rubout&\u\cr }}

The combinations marked by an asterisk (*) are explicitly reserved to the user.  No //[[CL:Glossary:conforming implementation]]// defines them.

Note also that //[[CL:Glossary:digits]]// do not appear in the preceding table.  This is because the notations {\tt \#0}, {\tt \#1}, ..., {\tt \#9} are reserved for another purpose which occupies the same syntactic space. When a //[[CL:Glossary:digit]]// follows a //[[CL:Glossary:sharpsign]]//, it is not treated as a dispatch character. Instead, an unsigned integer argument is accumulated  and passed as an //[[CL:Glossary:argument]]// to the //[[CL:Glossary:reader macro]]//  for the //[[CL:Glossary:character]]// that follows the digits. For example, \f{\#2A((1 2) (3 4))} is a use of {\tt \#A} with an argument of \f{2}.

\beginsubsubsection{Sharpsign Backslash} \DefineSection{SharpsignBackslash} \idxtext{Sharpsign Backslash (reader macro)}\idxtext{Backslash (sharpsign reader macro)}\idxref{character}

\b{Syntax:} \f{\#\\\metaparam{x}}

When the //[[CL:Glossary:token]]// //x// is a single //[[CL:Glossary:character]]// long,  this parses as the literal //[[CL:Glossary:character]]// //char//.

//[[CL:Glossary:Uppercase]]// and //[[CL:Glossary:lowercase]]// letters are distinguished after \f{\#\\}; \f{\#\\A} and \f{\#\\a} denote different //[[CL:Glossary:character]]// //[[CL:Glossary:objects]]//. Any single //[[CL:Glossary:character]]// works after \f{\#\\}, even those that are normally special to **[[CL:Functions:read]]**,  such as //[[CL:Glossary:left-parenthesis]]// and //[[CL:Glossary:right-parenthesis]]//.

In the single //[[CL:Glossary:character]]// case, the //x// must be followed by a non-constituent //[[CL:Glossary:character]]//. After \f{\#\\} is read, the reader backs up over the //[[CL:Glossary:slash]]// and then reads a //[[CL:Glossary:token]]//, treating the initial //[[CL:Glossary:slash]]// as a //[[CL:Glossary:single escape]]// //[[CL:Glossary:character]]// (whether it really is or not in the //[[CL:Glossary:current readtable]]//).

When the //[[CL:Glossary:token]]// //x// is more than one //[[CL:Glossary:character]]// long,

the //x// must have the syntax of a //[[CL:Glossary:symbol]]//  with no embedded //[[CL:Glossary:package markers]]//. In this case, the //[[CL:Glossary:sharpsign]]// //[[CL:Glossary:backslash]]// notation parses as the //[[CL:Glossary:character]]// whose //[[CL:Glossary:name]]// is \f{(string-upcase //x//)}; \seesection\CharacterNames.

\issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-LOOSE-ENDS:FIX}

For information about how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:character]]// //[[CL:Glossary:objects]]//, \seesection\PrintingCharacters.

\endsubsubsection%{Sharpsign Backslash}

\beginsubsubsection{Sharpsign Single-Quote} \DefineSection{SharpsignQuote} \idxtext{Sharpsign Single-Quote (reader macro)}\idxtext{Single-Quote (sharpsign reader macro)}\idxref{function}

Any //expression// preceded by \f{\#'}  (//[[CL:Glossary:sharpsign]]// followed by //[[CL:Glossary:single-quote]]//), as in \f{\#'//expression//}, is treated by the //[[CL:Glossary:Lisp reader]]// as an abbreviation for and parsed identically  to the //[[CL:Glossary:expression]]// \f{(function //expression//)}. See \specref{function}.  For example,

\code (apply #'+ l) \EQ (apply (function +) l) \endcode

\endsubsubsection%{Sharpsign Single-Quote}
                    \beginsubsubsection{Sharpsign Left-Parenthesis} \DefineSection{SharpsignLeftParen} \idxtext{Sharpsign Left-Parenthesis (reader macro)}\idxtext{Left-Parenthesis (sharpsign reader macro)}\idxref{vector}\idxref{simple-vector}

\f{\#(} and \f{)} are used to notate a //[[CL:Glossary:simple vector]]//. 

If an unsigned decimal integer appears between the \f{\#} and \f{(}, it specifies explicitly the length of the //[[CL:Glossary:vector]]//.   The consequences are undefined if the number of //[[CL:Glossary:objects]]//  specified before the closing \f{)} exceeds the unsigned decimal integer. If the number of //[[CL:Glossary:objects]]// supplied before the closing \f{)} is less than the unsigned decimal integer but greater than zero, the last //[[CL:Glossary:object]]// is used to fill all remaining elements of the //[[CL:Glossary:vector]]//. \editornote{Barmar: This should say "signals...".} The consequences are undefined if the unsigned decimal integer is non-zero and number of //[[CL:Glossary:objects]]// supplied before the closing \f{)} is zero. For example,

\code
 #(a b c c c c)
 #6(a b c c c c)
 #6(a b c)
 #6(a b c c) \endcode

all mean the same thing: a //[[CL:Glossary:vector]]// of length \f{6} with //[[CL:Glossary:elements]]// \f{a}, \f{b}, and four occurrences of \f{c}.   Other examples follow:

\code
 #(a b c)               ;A vector of length 3
 #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)
                        ;A vector containing the primes below 50
 #()                    ;An empty vector \endcode The notation \f{\#()} denotes an empty //[[CL:Glossary:vector]]//, as does \f{\#0()}.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:vectors]]//, see \secref\PrintingStrings,
    \secref\PrintingBitVectors,
 or \secref\PrintingOtherVectors.

\endsubsubsection%{Sharpsign Left-Parenthesis}

\beginsubsubsection{Sharpsign Asterisk} \DefineSection{SharpsignStar} \idxtext{Sharpsign Asterisk (reader macro)}\idxtext{Asterisk (sharpsign reader macro)}\idxref{bit-vector}\idxref{simple-bit-vector}

\b{Syntax:} \f{\#*\metaparam{bits}}

A //[[CL:Glossary:simple bit vector]]// is constructed containing the indicated //[[CL:Glossary:bits]]// (\f{0}'s and \f{1}'s), where the leftmost //bit// has index zero  and the subsequent //bits// have increasing indices.

\b{Syntax:} \f{\#\metaparam{n}*\metaparam{bits}}

With an argument //n//, the //[[CL:Glossary:vector]]// to be created is of //[[CL:Glossary:length]]// //n//. If the number of //bits// is less than //n// but greater than zero, the last bit is used to fill all remaining bits of the //[[CL:Glossary:bit vector]]//.

The notations \f{\#*} and \f{\#0*} each denote an empty //[[CL:Glossary:bit vector]]//.

\issue{SHARP-STAR-DELIMITER:NORMAL-DELIMITER} Regardless of whether the optional numeric argument //n// is provided, the //[[CL:Glossary:token]]// that follows the //[[CL:Glossary:asterisk]]// is delimited by  a normal //[[CL:Glossary:token]]// delimiter. However, (unless \thevalueof{*read-suppress*} is //[[CL:Glossary:true]]//) an error \oftype{reader-error} is signaled 
     if that //[[CL:Glossary:token]]// is not composed entirely of \f{0}'s and \f{1}'s,
  or if //n// was supplied 
        and the //[[CL:Glossary:token]]// is composed of more than //n// //bits//,
  or if //n// is greater than one, but no //bits// were specified. Neither a //[[CL:Glossary:single escape]]// nor a //[[CL:Glossary:multiple escape]]// is permitted in this //[[CL:Glossary:token]]//.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:bit vectors]]//, \seesection\PrintingBitVectors.

\beginsubsubsubsection{Examples of Sharpsign Asterisk}

For example,  \code
  #*101111
 #6*101111
 #6*101
 #6*1011 \endcode all mean the same thing: a //[[CL:Glossary:vector]]// of length \f{6} with //[[CL:Glossary:elements]]// \f{1}, \f{0}, \f{1}, \f{1}, \f{1}, and \f{1}.

For example:

\code
 #*         ;An empty bit-vector \endcode

\endsubsubsubsection%{Examples of Sharpsign Asterisk}

\endsubsubsection%{Sharpsign Asterisk}

\beginsubsubsection{Sharpsign Colon} \DefineSection{SharpsignColon} \idxtext{Sharpsign Colon (reader macro)}\idxtext{Colon (sharpsign reader macro)}\idxref{symbol}

\b{Syntax:}  \f{\#:\metaparam{symbol-name}}

\f{\#:} introduces an //[[CL:Glossary:uninterned]]// //[[CL:Glossary:symbol]]// whose //[[CL:Glossary:name]]//  is //symbol-name//.  Every time this syntax is encountered, a //[[CL:Glossary:distinct]]// //[[CL:Glossary:uninterned]]// //[[CL:Glossary:symbol]]// is created. The //symbol-name// must have the syntax of a //[[CL:Glossary:symbol]]//  with no //[[CL:Glossary:package prefix]]//.

For information on how the //[[CL:Glossary:Lisp reader]]//  prints //[[CL:Glossary:uninterned]]// //[[CL:Glossary:symbols]]//, \seesection\PrintingSymbols.

\endsubsubsection%{Sharpsign Colon}

\beginsubsubsection{Sharpsign Dot} \DefineSection{SharpsignDot} \idxtext{Sharpsign Dot (reader macro)}\idxtext{Dot (sharpsign reader macro)}\idxref{eval}\idxref{*read-eval*}

\f{\#.//foo//} is read as the //[[CL:Glossary:object]]// resulting from the evaluation of the //[[CL:Glossary:object]]// represented by //foo//. The evaluation is done during the **[[CL:Functions:read]]** process, when the \f{\#.} notation is encountered. The \f{\#.} syntax therefore performs a read-time evaluation of //foo//.

The normal effect of {\tt \#.} is inhibited when \thevalueof{*read-eval*} is //[[CL:Glossary:false]]//.

\issue{PARSE-ERROR-STREAM:SPLIT-TYPES} In that situation, an error \oftype{reader-error} is signaled.

For an //[[CL:Glossary:object]]// that does not have a convenient printed representation, a //[[CL:Glossary:form]]// that computes the //[[CL:Glossary:object]]// can be given using the \f{\#.} notation. \issue{SHARP-COMMA-CONFUSION:REMOVE}

\endsubsubsection%{Sharpsign Dot}

\issue{SHARP-COMMA-CONFUSION:REMOVE}

\beginsubsubsection{Sharpsign B} \DefineSection{SharpsignB} \idxtext{Sharpsign B (reader macro)}\idxtext{B (sharpsign reader macro)}\idxref{*read-base*}

\f{\#B}//rational// reads //rational// in binary (radix 2). For example, 

\code
 #B1101 \EQ 13 ;1101\ssst
 #b101/11 \EQ 5/3 \endcode

\issue{SHARP-O-FOOBAR:CONSEQUENCES-UNDEFINED} The consequences are undefined if the token immediately following the \f{\#B} does not have the syntax of a binary (\ie radix 2) //[[CL:Glossary:rational]]//.

\endsubsubsection%{Sharpsign B}

\beginsubsubsection{Sharpsign O} \DefineSection{SharpsignO} \idxtext{Sharpsign O (reader macro)}\idxtext{O (sharpsign reader macro)}\idxref{*read-base*}

\f{\#O}//rational// reads //rational// in octal (radix 8). For example, 

\code
 #o37/15 \EQ 31/13
 #o777 \EQ 511
 #o105 \EQ 69 ;105\ssse \endcode

\issue{SHARP-O-FOOBAR:CONSEQUENCES-UNDEFINED} The consequences are undefined if the token immediately following the \f{\#O} does not have the syntax of an octal (\ie radix 8) //[[CL:Glossary:rational]]//.

\endsubsubsection%{Sharpsign O}

\beginsubsubsection{Sharpsign X} \DefineSection{SharpsignX} \idxtext{Sharpsign X (reader macro)}\idxtext{X (sharpsign reader macro)}\idxref{*read-base*}

\f{\#X}//rational// reads //rational// in hexadecimal (radix 16). The digits above \f{9} are the letters \f{A} through \f{F} (the lowercase letters \f{a} through \f{f} are also acceptable).  For example,

\code
 #xF00 \EQ 3840             
 #x105 \EQ 261 ;105\ssss \endcode

\issue{SHARP-O-FOOBAR:CONSEQUENCES-UNDEFINED} The consequences are undefined if the token immediately following the \f{\#X} does not have the syntax of a hexadecimal (\ie radix 16) //[[CL:Glossary:rational]]//.

\endsubsubsection%{Sharpsign X}

\beginsubsubsection{Sharpsign R} \DefineSection{SharpsignR} \idxtext{Sharpsign R (reader macro)}\idxtext{R (sharpsign reader macro)}\idxref{*read-base*}

\f{\#//n//R}
                                                              \f{\#//radix//R//rational//} reads //rational// in radix //radix//. //radix// must consist of only digits that are interpreted as an //[[CL:Glossary:integer]]// in decimal radix; its value must be between 2 and 36 (inclusive). Only valid digits for the specified radix may be used.

For example, \f{\#3r102} is another way of writing \f{11} (decimal),  and \f{\#11R32} is another way of writing \f{35} (decimal).   For radices larger than 10, letters of the alphabet are used in order for the digits after \f{9}. No alternate \f{\#} notation exists for the decimal radix since a decimal point suffices.

\Thenextfigure\ contains examples of the use of {\tt\#B}, {\tt \#O}, {\tt \#X}, and {\tt \#R}.

\showtwo{Radix Indicator Example}{ \f{\#2r11010101}  & ;Another way of writing \f{213} decimal \cr \f{\#b11010101}   & ;Ditto                                  \cr \f{\#b+11010101}  & ;Ditto                                  \cr \f{\#o325}        & ;Ditto, in octal radix                  \cr \f{\#xD5}         & ;Ditto, in hexadecimal radix            \cr \f{\#16r+D5}      & ;Ditto                                  \cr \f{\#o-300}       & ;Decimal \f{-192}, written in base 8    \cr \f{\#3r-21010}    & ;Same thing in base 3                   \cr \f{\#25R-7H}      & ;Same thing in base 25                  \cr \f{\#xACCEDED}    & ;\f{181202413}, in hexadecimal radix    \cr }

\issue{SHARP-O-FOOBAR:CONSEQUENCES-UNDEFINED} The consequences are undefined if the token immediately following the \f{\#//n//R} does not have the syntax of a //[[CL:Glossary:rational]]// in radix //n//.

\endsubsubsection%{Sharpsign R}

\beginsubsubsection{Sharpsign C} \DefineSection{SharpsignC} \idxtext{Sharpsign C (reader macro)}\idxtext{C (sharpsign reader macro)}\idxref{complex}

\issue{READ-SUPPRESS-CONFUSING:GENERALIZE}

\f{\#C} reads a following //[[CL:Glossary:object]]//, which must be a //[[CL:Glossary:list]]// of length two whose //[[CL:Glossary:elements]]// are both //[[CL:Glossary:reals]]//. These //[[CL:Glossary:reals]]// denote, respectively, the real and imaginary parts of a //[[CL:Glossary:complex]]// number.

If the two parts as notated are not of the same data type, then they are converted  according to the rules of floating-point //[[CL:Glossary:contagion]]// described in \secref\NumericContagionRules.

\f{\#C(//real// //imag//)} is equivalent to  \f{\#.(complex (quote //real//) (quote //imag//))},

except that \f{\#C} is not affected by \varref{*read-eval*}. \Seefun{complex}.

\Thenextfigure\ contains examples of the use of {\tt \#C}.

\showtwo{Complex Number Example}{ \f{\#C(3.0s1 2.0s-1)} & ;A //[[CL:Glossary:complex]]// with //[[CL:Glossary:small float]]// parts.      \cr \f{\#C(5 -3)      }   & ;A ``Gaussian integer''                               \cr \f{\#C(5/3 7.0) }     & ;Will be converted internally to \f{\#C(1.66666 7.0)} \cr \f{\#C(0 1)}          & ;The imaginary unit; that is, i.                      \cr }

For further information,  \seesection\PrintingComplexes\ and \secref\SyntaxOfComplexes.

\endsubsubsection%{Sharpsign C}

\beginsubsubsection{Sharpsign A} \DefineSection{SharpsignA} \idxtext{Sharpsign A (reader macro)}\idxtext{A (sharpsign reader macro)}\idxref{array}

\f{\#//n//A}

\f{\#//n//\f{A}//object//} constructs an //n//-dimensional //[[CL:Glossary:array]]//, using //object// as the value of the **'':initial-contents''** argument to **[[CL:Functions:make-array]]**.

For example, \f{\#2A((0 1 5) (foo 2 (hot dog)))} represents a 2-by-3 matrix:

\code
 0       1       5
 foo     2       (hot dog) \endcode In contrast, \f{\#1A((0 1 5) (foo 2 (hot dog)))}  represents a //[[CL:Glossary:vector]]// of //[[CL:Glossary:length]]// \f{2}  whose //[[CL:Glossary:elements]]// are //[[CL:Glossary:lists]]//:

\code
 (0 1 5) (foo 2 (hot dog)) \endcode \f{\#0A((0 1 5) (foo 2 (hot dog)))} represents a zero-dimensional //[[CL:Glossary:array]]// whose sole element is a //[[CL:Glossary:list]]//:

\code
 ((0 1 5) (foo 2 (hot dog))) \endcode \f{\#0A foo} represents  a zero-dimensional //[[CL:Glossary:array]]// whose sole element is the  //[[CL:Glossary:symbol]]// \f{foo}. The notation \f{\#1A foo} is not valid because \f{foo} is not a //[[CL:Glossary:sequence]]//.

If some //[[CL:Glossary:dimension]]// of the //[[CL:Glossary:array]]// whose representation is being parsed is found to be \f{0}, all //[[CL:Glossary:dimensions]]// to the right  (\ie the higher numbered //[[CL:Glossary:dimensions]]//) are also considered to be \f{0}.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:arrays]]//, see \secref\PrintingStrings,
    \secref\PrintingBitVectors,
    \secref\PrintingOtherVectors,
 or \secref\PrintingOtherArrays.

\endsubsubsection%{Sharpsign A}

\beginsubsubsection{Sharpsign S} \DefineSection{SharpsignS} \idxtext{Sharpsign S (reader macro)}\idxtext{S (sharpsign reader macro)}\idxref{structure}

\f{\#s(name slot1 value1 slot2 value2 ...)} denotes a //[[CL:Glossary:structure]]//.  This is valid only if //name// is the name of a //[[CL:Glossary:structure]]// //[[CL:Glossary:type]]// already defined by \macref{defstruct}  and if the //[[CL:Glossary:structure]]// //[[CL:Glossary:type]]// has a standard constructor function. Let //cm// stand for the name of this constructor function; then this syntax is equivalent to

\code
 #.(cm keyword1 'value1 keyword2 'value2 ...) \endcode

where each //keywordj// is the result of computing

\code
 (intern (string slotj) (find-package 'keyword)) \endcode
     The net effect is that the constructor function is called with the specified slots having the specified values.  \issue{STRUCTURE-READ-PRINT-SYNTAX:KEYWORDS} (This coercion feature is deprecated; in the future, keyword names will 
 be taken in the package they are read in, so //[[CL:Glossary:symbols]]// that are 
 actually in \thepackage{keyword} should be used if that is what is desired.)

Whatever //[[CL:Glossary:object]]// the constructor function returns is returned by the \f{\#S} syntax.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:structures]]//, \seesection\PrintingStructures.

\endsubsubsection%{Sharpsign S}

\beginsubsubsection{Sharpsign P} \DefineSection{SharpsignP} \idxtext{Sharpsign P (reader macro)}\idxtext{P (sharpsign reader macro)}\idxref{pathname}

\issue{PATHNAME-PRINT-READ:SHARPSIGN-P}                  

\f{\#P} reads a following //[[CL:Glossary:object]]//, which must be a //[[CL:Glossary:string]]//.

\f{\#P\metaparam{expression}} is equivalent to  \f{\#.(parse-namestring '\metaparam{expression})},

except that \f{\#P} is not affected by \varref{*read-eval*}.

For information on how the //[[CL:Glossary:Lisp printer]]// prints //[[CL:Glossary:pathnames]]//, see \secref\PrintingPathnames.

\endsubsubsection%{Sharpsign P}

\beginsubsubsection{Sharpsign Equal-Sign} \idxtext{Sharpsign Equal-Sign (reader macro)}\idxtext{Equal-Sign (sharpsign reader macro)}\idxref{*print-circle*}

\f{\#//n//=}

\f{\#//n//=//object//} reads as whatever //[[CL:Glossary:object]]// has //object// as its printed representation.  However, that //[[CL:Glossary:object]]// is labeled by //n//, a required unsigned decimal integer, for possible reference by the syntax \f{\#//n//\#}. The scope of the label is the //[[CL:Glossary:expression]]// being read by the outermost call to **[[CL:Functions:read]]**; within this //[[CL:Glossary:expression]]//, the same label may not appear twice.

\endsubsubsection%{Sharpsign Equal-Sign}

\beginsubsubsection{Sharpsign Sharpsign} \idxtext{Sharpsign Sharpsign (reader macro)}\idxtext{Sharpsign (sharpsign reader macro)}\idxref{*print-circle*}

\f{\#//n//\#}
  \f{\#//n//\#}, where //n// is a required unsigned decimal //[[CL:Glossary:integer]]//, provides a reference to some //[[CL:Glossary:object]]// labeled by \f{\#//n//=}; that is, \f{\#//n//\#} represents a pointer to the same  (**[[CL:Functions:eq]]**) //[[CL:Glossary:object]]// labeled by \f{\#//n//=}. For example, a structure created in the variable \f{y} by this code:

\code
 (setq x (list 'p 'q))
 (setq y (list (list 'a 'b) x 'foo x))
 (rplacd (last y) (cdr y)) \endcode could be represented in this way:

\code
 ((a b) . #1=(#2=(p q) foo #2# . #1#)) \endcode Without this notation, but with \varref{*print-length*} set to \f{10} and \varref{*print-circle*} set to \nil, the structure would print in this way:

\code
 ((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...) \endcode A reference \f{\#//n//\#} may only occur after a label \f{\#//n//=}; forward references are not permitted.  The reference may not appear as the labeled object itself (that is, \f{\#//n//=\#//n//\#}) may not be written  because the //[[CL:Glossary:object]]// labeled by \f{\#//n//=} is not well defined in this case.

\endsubsubsection%{Sharpsign Sharpsign}

\beginsubsubsection{Sharpsign Plus} \idxtext{Sharpsign Plus (reader macro)}\idxtext{Plus (sharpsign reader macro)}\idxref{*features*}

\f{\#+} provides a read-time conditionalization facility; the syntax is \f{\#+//test// //expression//}. If the //[[CL:Glossary:feature expression]]// //test// succeeds, then this textual notation represents an //[[CL:Glossary:object]]//
 whose printed representation is //expression//. If the //[[CL:Glossary:feature expression]]// //test// fails, then this textual notation is treated as //[[CL:Glossary:whitespace]]//\meaning{2}; 
 that is, it is as if the ``\f{\#+} //test// //expression//'' 
 did not appear and only a //[[CL:Glossary:space]]// appeared in its place.

For a detailed description of success and failure in //[[CL:Glossary:feature expressions]]//, \seesection\FeatureExpressions.

\f{\#+} operates by first reading the //[[CL:Glossary:feature expression]]// and then skipping over the //form// if the //[[CL:Glossary:feature expression]]// fails. \issue{SHARPSIGN-PLUS-MINUS-PACKAGE:KEYWORD} While reading the //test//, the //[[CL:Glossary:current package]]// is \thepackage{keyword}.

Skipping over the //form// is accomplished by //[[CL:Glossary:binding]]//  \varref{*read-suppress*} to //[[CL:Glossary:true]]// and then calling **[[CL:Functions:read]]**.

For examples, \seesection\FeatureExpExamples.

\endsubsubsection%{Sharpsign Plus}

\beginsubsubsection{Sharpsign Minus} \idxtext{Sharpsign Minus (reader macro)}\idxtext{Minus (sharpsign reader macro)}\idxref{*features*}

\f{\#-} is like \f{\#+}  except that it skips the //expression// if the //test// succeeds;  that is,

\code #-//test// //expression// \EQ #+(not //test//) //expression// \endcode

For examples, \seesection\FeatureExpExamples.

\endsubsubsection%{Sharpsign Minus}

\beginsubsubsection{Sharpsign Vertical-Bar} \idxtext{Sharpsign Vertical-Bar (reader macro)}\idxtext{Vertical-Bar (sharpsign reader macro)}\idxtext{comment}

\f{\#|...|\#} is treated as a comment by the reader. It must be balanced with respect to other occurrences of \f{\#|} and \f{|\#}, but otherwise may contain any characters whatsoever.

\beginsubsubsubsection{Examples of Sharpsign Vertical-Bar}

The following are some examples that exploit the \f{\#|...|\#} notation:

\code ;;; In this example, some debugging code is commented out with #|...|# ;;; Note that this kind of comment can occur in the middle of a line ;;; (because a delimiter marks where the end of the comment occurs) ;;; where a semicolon comment can only occur at the end of a line  ;;; (because it comments out the rest of the line).
 (defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3)) \goodbreak ;;; The examples that follow show issues related to #| ... |# nesting.

;;; In this first example, #| and |# always occur properly paired, ;;; so nesting works naturally.
 (defun mention-fun-fact-1a ()
   (format t "CL uses ; and #|...|# in comments.")) \EV MENTION-FUN-FACT-1A
 (mention-fun-fact-1a) \OUT CL uses ; and #|...|# in comments. \EV NIL
 #| (defun mention-fun-fact-1b ()
      (format t "CL uses ; and #|...|# in comments.")) |#
 (fboundp 'mention-fun-fact-1b) \EV NIL \goodbreak ;;; In this example, vertical-bar followed by sharpsign needed to appear ;;; in a string without any matching sharpsign followed by vertical-bar ;;; having preceded this.  To compensate, the programmer has included a ;;; slash separating the two characters.  In case 2a, the slash is  ;;; unnecessary but harmless, but in case 2b, the slash is critical to ;;; allowing the outer #| ... |# pair match.  If the slash were not present, ;;; the outer comment would terminate prematurely.
 (defun mention-fun-fact-2a ()
   (format t "Don't use |\\# unmatched or you'll get in trouble!")) \EV MENTION-FUN-FACT-2A
 (mention-fun-fact-2a) \OUT Don't use |# unmatched or you'll get in trouble! \EV NIL
 #| (defun mention-fun-fact-2b ()
      (format t "Don't use |\\# unmatched or you'll get in trouble!") |#
 (fboundp 'mention-fun-fact-2b) \EV NIL \goodbreak ;;; In this example, the programmer attacks the mismatch problem in a ;;; different way.  The sharpsign vertical bar in the comment is not needed ;;; for the correct parsing of the program normally (as in case 3a), but  ;;; becomes important to avoid premature termination of a comment when such  ;;; a program is commented out (as in case 3b).
 (defun mention-fun-fact-3a () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!")) \EV MENTION-FUN-FACT-3A
 (mention-fun-fact-3a) \OUT Don't use |# unmatched or you'll get in trouble! \EV NIL
 #|
 (defun mention-fun-fact-3b () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!"))
 |#
 (fboundp 'mention-fun-fact-3b) \EV NIL \endcode

\endsubsubsubsection%{Examples of Sharpsign Vertical-Bar}

\beginsubsubsubsection{Notes about Style for Sharpsign Vertical-Bar}

Some text editors that purport to understand Lisp syntax treat any \f{|...|} as balanced pairs that cannot nest (as if they were just balanced pairs of  the multiple escapes used in notating certain symbols).  To compensate for  this deficiency, some programmers use the notation \f{\#||...\#||...||\#...||\#} instead of \f{\#|...\#|...|\#...|\#}.   Note that this alternate usage is not a different //[[CL:Glossary:reader macro]]//; it merely exploits the fact that the additional vertical-bars occur within the comment in a way that tricks certain text editor into better supporting nested comments.  As such, one might sometimes see code like:

\code
 #|| (+ #|| 3 ||# 4 5) ||#  \endcode

Such code is equivalent to:

\code
 #| (+ #| 3 |# 4 5) |# \endcode

\endsubsubsubsection%{Notes about Style for Sharpsign Vertical-Bar}

\endsubsubsection%{Sharpsign Vertical-Bar}

\beginsubsubsection{Sharpsign Less-Than-Sign} \DefineSection{SharpsignLeftAngle} \idxtext{Sharpsign Less-Than-Sign (reader macro)}\idxtext{Less-Than-Sign (sharpsign reader macro)}

{\tt  \#<} is not valid reader syntax. The //[[CL:Glossary:Lisp reader]]// will signal an error  \issue{PARSE-ERROR-STREAM:SPLIT-TYPES} \oftype{reader-error}

on encountering \f{\#<}. This syntax is typically used in the printed representation  of //[[CL:Glossary:objects]]// that cannot be read back in.  

\endsubsubsection%{Sharpsign Less-Than-Sign}

\beginsubsubsection{Sharpsign Whitespace} \idxtext{Sharpsign Whitespace}

\f{\#} followed immediately by //[[CL:Glossary:whitespace]]//\meaning{1} is not valid reader syntax. The //[[CL:Glossary:Lisp reader]]// will signal an error \oftype{reader-error} if it encounters the reader macro notation \f{\#\NewlineChar} or \f{\#\SpaceChar}.

\endsubsubsection%{Sharpsign Whitespace}

\beginsubsubsection{Sharpsign Right-Parenthesis} \idxtext{Sharpsign Right-Parenthesis}

This is not valid reader syntax.

The //[[CL:Glossary:Lisp reader]]// will signal an error  \issue{PARSE-ERROR-STREAM:SPLIT-TYPES} \oftype{reader-error}

upon encountering \f{\#)}.

\endsubsubsection%{Sharpsign Right-Parenthesis}

\endsubsection%{Sharpsign}

\beginsubsection{Re-Reading Abbreviated Expressions} \idxtext{Dot Dot}\idxcode{..} \idxtext{Dot Dot Dot}\idxcode{...} \idxtext{Sharpsign Whitespace}\idxtext{Sharpsign Right-Parenthesis}

Note that the //[[CL:Glossary:Lisp reader]]// will 

generally signal an error \oftype{reader-error} when reading an //[[CL:Glossary:expression]]//\meaning{2} that has been abbreviated because of length or level limits  (see \varref{*print-level*},
     \varref{*print-length*},
 and \varref{*print-lines*}) due to restrictions on ``\f{..}'', ``\f{...}'', ``\f{\#}'' followed by //[[CL:Glossary:whitespace]]//\meaning{1},

and ``\f{\#)}''.

\endsubsection%{Re-Reading Abbreviated Expressions}
