--- saved-pages-dpans3/cl:functions:char-not-lessp.txt	2017-04-27 22:04:22.000000000 +0100
+++ saved-pages-clus/cl:functions:char-not-lessp.txt	2017-04-27 22:04:22.000000000 +0100
@@ -2,29 +4,31 @@
 Syntax
  
 
-char= &rest characters+ => generalized-boolean
+ char= &rest characters+ → generalized-boolean
+
+ char/= &rest characters+ → generalized-boolean
+
+ char< &rest characters+ → generalized-boolean
  
-char/= &rest characters+ => generalized-boolean
+ char> &rest characters+ → generalized-boolean
  
-char< &rest characters+ => generalized-boolean
+ char<= &rest characters+ → generalized-boolean
  
-char> &rest characters+ => generalized-boolean
+ char>= &rest characters+ → generalized-boolean
  
-char<= &rest characters+ => generalized-boolean
+ char-equal &rest characters+ → generalized-boolean
  
-char>= &rest characters+ => generalized-boolean
+ char-not-equal &rest characters+ → generalized-boolean
   
-char-equal &rest characters+ => generalized-boolean
+ char-lessp &rest characters+ → generalized-boolean
  
-char-not-equal &rest characters+ => generalized-boolean
+ char-greaterp &rest characters+ → generalized-boolean
  
-char-lessp &rest characters+ => generalized-boolean
+ char-not-greaterp &rest characters+ → generalized-boolean
  
-char-greaterp &rest characters+ => generalized-boolean
+ char-not-lessp &rest characters+ → generalized-boolean
  
-char-not-greaterp &rest characters+ => generalized-boolean
  
-char-not-lessp &rest characters+ => generalized-boolean
  
 Arguments and Values
  
@@ -28,67 +32,359 @@
  
 Arguments and Values
  
+
 character - a character. 
+
 generalized-boolean - a generalized boolean. 
+
+
+
 Description
  
+
 These predicates compare characters. 
-char= returns true if all characters are the same; otherwise, it returns false.  If two characters differ in any implementation-defined attributes, then they are not char=.  
+
+
+char= returns true if all characters are the same; otherwise, it returns false.
+
+
+If two characters differ in any implementation-defined attributes, then they are not char=.
+
+
 char/= returns true if all characters are different; otherwise, it returns false. 
-char< returns true if the characters are monotonically increasing; otherwise, it returns false.  If two characters have identical implementation-defined attributes, then their ordering by char< is consistent with the numerical ordering by the predicate < on their codes.  
-char> returns true if the characters are monotonically decreasing; otherwise, it returns false.  If two characters have identical implementation-defined attributes, then their ordering by char> is consistent with the numerical ordering by the predicate > on their codes.  
-char<= returns true if the characters are monotonically nondecreasing; otherwise, it returns false.  If two characters have identical implementation-defined attributes, then their ordering by char<= is consistent with the numerical ordering by the predicate <= on their codes.  
-char>= returns true if the characters are monotonically nonincreasing; otherwise, it returns false.  If two characters have identical implementation-defined attributes, then their ordering by char>= is consistent with the numerical ordering by the predicate >= on their codes.  
- char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, and char-not-lessp are similar to char=, char/=, char<, char>, char<=, char>=, respectively, except that they ignore differences in case and  might have an implementation-defined behavior for non-simple characters. For example, an implementation might define that char-equal, etc. ignore certain implementation-defined attributes. The effect, if any, of each implementation-defined attribute upon these functions must be specified as part of the definition of that attribute.  
+
+
+char< returns true if the characters are monotonically increasing; otherwise, it returns false.
+
+
+If two characters have identical implementation-defined attributes, then their ordering by char< is consistent with the numerical ordering by the predicate < on their codes.
+
+
+char> returns true if the characters are monotonically decreasing; otherwise, it returns false.
+
+
+If two characters have identical implementation-defined attributes, then their ordering by char> is consistent with the numerical ordering by the predicate > on their codes.
+
+
+char<= returns true if the characters are monotonically nondecreasing; otherwise, it returns false.
+
+
+If two characters have identical implementation-defined attributes, then their ordering by char<= is consistent with the numerical ordering by the predicate <= on their codes.
+
+
+char>= returns true if the characters are monotonically nonincreasing; otherwise, it returns false.
+
+
+If two characters have identical implementation-defined attributes, then their ordering by char>= is consistent with the numerical ordering by the predicate >= on their codes.
+
+
+char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, and char-not-lessp are similar to char=, char/=, char<, char>, char<=, char>=, respectively, except that they ignore differences in case and might have an implementation-defined behavior for non-simple characters.
+
+
+For example, an implementation might define that char-equal, etc. ignore certain implementation-defined attributes. The effect, if any, of each implementation-defined attribute upon these functions must be specified as part of the definition of that attribute.
+
+
 Examples
  
  
 
- (char= #\d #\d) =>  true
- (char= #\A #\a) =>  false
- (char= #\d #\x) =>  false
- (char= #\d #\D) =>  false
- (char/= #\d #\d) =>  false
- (char/= #\d #\x) =>  true
- (char/= #\d #\D) =>  true
- (char= #\d #\d #\d #\d) =>  true
- (char/= #\d #\d #\d #\d) =>  false
- (char= #\d #\d #\x #\d) =>  false
- (char/= #\d #\d #\x #\d) =>  false
- (char= #\d #\y #\x #\c) =>  false
- (char/= #\d #\y #\x #\c) =>  true
- (char= #\d #\c #\d) =>  false
- (char/= #\d #\c #\d) =>  false
- (char< #\d #\x) =>  true
- (char<= #\d #\x) =>  true
- (char< #\d #\d) =>  false
- (char<= #\d #\d) =>  true
- (char< #\a #\e #\y #\z) =>  true
- (char<= #\a #\e #\y #\z) =>  true
- (char< #\a #\e #\e #\y) =>  false
- (char<= #\a #\e #\e #\y) =>  true
- (char> #\e #\d) =>  true
- (char>= #\e #\d) =>  true
- (char> #\d #\c #\b #\a) =>  true
- (char>= #\d #\c #\b #\a) =>  true
- (char> #\d #\d #\c #\a) =>  false
- (char>= #\d #\d #\c #\a) =>  true
- (char> #\e #\d #\b #\c #\a) =>  false
- (char>= #\e #\d #\b #\c #\a) =>  false
- (char> #\z #\A) =>  implementation-dependent
- (char> #\Z #\a) =>  implementation-dependent
- (char-equal #\A #\a) =>  true
+(char= #\d #\d) 
+
+→
+
+true
+
+
+
+(char= #\A #\a) 
+
+→
+
+false
+
+
+
+(char= #\d #\x) 
+
+→
+
+false
+
+
+
+(char= #\d #\D) 
+
+→
+
+false
+
+
+
+(char/= #\d #\d) 
+
+→
+
+false
+
+
+
+(char/= #\d #\x) 
+
+→
+
+true
+
+
+
+(char/= #\d #\D) 
+
+→
+
+true
+
+
+
+(char= #\d #\d #\d #\d) 
+
+→
+
+true
+
+
+
+(char/= #\d #\d #\d #\d) 
+
+→
+
+false
+
+
+
+(char= #\d #\d #\x #\d) 
+
+→
+
+false
+
+
+
+(char/= #\d #\d #\x #\d) 
+
+→
+
+false
+
+
+
+(char= #\d #\y #\x #\c) 
+
+→
+
+false
+
+
+
+(char/= #\d #\y #\x #\c) 
+
+→
+
+true
+
+
+
+(char= #\d #\c #\d) 
+
+→
+
+false
+
+
+
+(char/= #\d #\c #\d) 
+
+→
+
+false
+
+
+
+(char< #\d #\x) 
+
+→
+
+true
+
+
+
+(char<= #\d #\x) 
+
+→
+
+true
+
+
+
+(char< #\d #\d) 
+
+→
+
+false
+
+
+
+(char<= #\d #\d) 
+
+→
+
+true
+
+
+
+(char< #\a #\e #\y #\z) 
+
+→
+
+true
+
+
+
+(char<= #\a #\e #\y #\z) 
+
+→
+
+true
+
+
+
+(char< #\a #\e #\e #\y) 
+
+→
+
+false
+
+
+
+(char<= #\a #\e #\e #\y) 
+
+→
+
+true
+
+
+
+(char> #\e #\d) 
+
+→
+
+true
+
+
+
+(char>= #\e #\d) 
+
+→
+
+true
+
+
+
+(char> #\d #\c #\b #\a) 
+
+→
+
+true
+
+
+
+(char>= #\d #\c #\b #\a) 
+
+→
+
+true
+
+
+
+(char> #\d #\d #\c #\a) 
+
+→
+
+false
+
+
+
+(char>= #\d #\d #\c #\a) 
+
+→
+
+true
+
+
+
+(char> #\e #\d #\b #\c #\a) 
+
+→
+
+false
+
+
+
+(char>= #\e #\d #\b #\c #\a) 
+
+→
+
+false
+
+
+
+(char> #\z #\A) 
+
+→
+
+implementation-dependent
+
+
+
+(char> #\Z #\a) 
+
+→
+
+implementation-dependent
+
+
+
+(char-equal #\A #\a) 
+
+→
+
+true
+
+
+
  (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
-=>  (#\A #\a #\b #\B #\c #\C)
+
+→
+
+(#\A #\a #\b #\B #\c #\C) 
+
+
+
  (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
-=>  (#\A #\B #\C #\a #\b #\c) ;Implementation A
-=>  (#\a #\b #\c #\A #\B #\C) ;Implementation B
-=>  (#\a #\A #\b #\B #\c #\C) ;Implementation C
-=>  (#\A #\a #\B #\b #\C #\c) ;Implementation D
-=>  (#\A #\B #\a #\b #\C #\c) ;Implementation E
 
-<TT>  
-Affected By None.
+→
+
+(#\A #\B #\C #\a #\b #\c)    ; Implementation A 
+or (#\a #\b #\c #\A #\B #\C) ; Implementation B 
+or (#\a #\A #\b #\B #\c #\C) ; Implementation C
+or (#\A #\a #\B #\b #\C #\c) ; Implementation D
+or (#\A #\B #\a #\b #\C #\c) ; Implementation E
+
+
+
+Affected By
+
+
+None.
+
  
 Exceptional Situations
  
@@ -92,12 +388,26 @@
  
 Exceptional Situations
  
+
 Should signal an error of type program-error if at least one character is not supplied. 
+
+
 See Also
  
-Section 2.1 (Character Syntax), Section 13.1.10 (Documentation of Implementation-Defined Scripts) 
+
+{\secref\CharacterSyntax}, {\secref\ImplementationDefinedScripts}
+
+
 Notes
  
+
 If characters differ in their code attribute or any implementation-defined attribute, they are considered to be different by char=. 
+
+
 There is no requirement that (eq c1 c2) be true merely because (char= c1 c2) is true. While eq can distinguish two characters that char= does not, it is distinguishing them not as characters, but in some sense on the basis of a lower level implementation characteristic. If (eq c1 c2) is true, then (char= c1 c2) is also true. eql and equal compare characters in the same way that char= does. 
+
+
 The manner in which case is used by char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, and char-not-lessp implies an ordering for standard characters such that A=a, B=b, and so on, up to Z=z, and furthermore either 9<A or Z<0.
\ No newline at end of file
+
+
+\
\ No newline at end of file
